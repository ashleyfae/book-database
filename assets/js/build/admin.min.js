/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/src/admin/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/src/admin/components/editions.js":
/*!****************************************************!*\
  !*** ./assets/js/src/admin/components/editions.js ***!
  \****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils */ "./assets/js/src/utils/index.js");
/* harmony import */ var _utils_edit_display_toggle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/edit-display-toggle */ "./assets/js/src/admin/utils/edit-display-toggle.js");
/* global bdbVars, wp */


document.addEventListener('alpine:init', function () {
  Alpine.data('bdbEditions', function (bookId) {
    return {
      loaded: false,
      editions: [],
      mode: 'view',
      bookId: bookId,
      error: null,
      init: function init() {
        this.getEditions();
      },
      getEditions: function getEditions() {
        var editions = this;
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/edition', {
          book_id: editions.bookId,
          number: 50
        }, 'GET').then(function (response) {
          editions.editions = response;
          editions.loaded = true;
        }).catch(function (error) {
          editions.error = error;
        });
      },
      toggleEditFields: function toggleEditFields(editionId) {
        var button = this.$el;
        var tableRow = document.querySelector('.bdb-editions-list-' + editionId);

        if (!tableRow) {
          return;
        }

        Object(_utils_edit_display_toggle__WEBPACK_IMPORTED_MODULE_1__["default"])(tableRow, true); // @todo show "Save" button instead somehow.
      }
    };
  });
});

/***/ }),

/***/ "./assets/js/src/admin/index.js":
/*!**************************************!*\
  !*** ./assets/js/src/admin/index.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_book_layout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/book-layout.js */ "./assets/js/src/admin/modules/book-layout.js");
/* harmony import */ var _modules_book_index_title__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/book-index-title */ "./assets/js/src/admin/modules/book-index-title.js");
/* harmony import */ var _modules_book_links__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/book-links */ "./assets/js/src/admin/modules/book-links.js");
/* harmony import */ var _modules_categories__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/categories */ "./assets/js/src/admin/modules/categories.js");
/* harmony import */ var _modules_datepicker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/datepicker */ "./assets/js/src/admin/modules/datepicker.js");
/* harmony import */ var _modules_delete_objects__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/delete-objects */ "./assets/js/src/admin/modules/delete-objects.js");
/* harmony import */ var _modules_editions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/editions */ "./assets/js/src/admin/modules/editions.js");
/* harmony import */ var _modules_license__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/license */ "./assets/js/src/admin/modules/license.js");
/* harmony import */ var _modules_media_upload__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/media-upload */ "./assets/js/src/admin/modules/media-upload.js");
/* harmony import */ var _modules_reading_logs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/reading-logs */ "./assets/js/src/admin/modules/reading-logs.js");
/* harmony import */ var _modules_retailers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/retailers */ "./assets/js/src/admin/modules/retailers.js");
/* harmony import */ var _modules_tags__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/tags */ "./assets/js/src/admin/modules/tags.js");
/* harmony import */ var _modules_taxonomies_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/taxonomies.js */ "./assets/js/src/admin/modules/taxonomies.js");
/* harmony import */ var _components_editions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/editions */ "./assets/js/src/admin/components/editions.js");
/**
 * Admin Scripts
 *
 * @package book-database
 * @copyright Copyright (c) 2019, Ashley Gibson
 * @license GPL2+
 */














(function ($) {
  _modules_book_layout_js__WEBPACK_IMPORTED_MODULE_0__["BDB_Book_Layout"].init();
  _modules_book_index_title__WEBPACK_IMPORTED_MODULE_1__["BDB_Book_Index_Title"].init();
  _modules_book_links__WEBPACK_IMPORTED_MODULE_2__["BDB_Book_Links"].init();
  _modules_categories__WEBPACK_IMPORTED_MODULE_3__["BDB_Categories"].init();
  _modules_datepicker__WEBPACK_IMPORTED_MODULE_4__["BDB_Datepicker"].init();
  _modules_delete_objects__WEBPACK_IMPORTED_MODULE_5__["BDB_Delete_Objects"].init(); //BDB_Editions.init();

  _modules_license__WEBPACK_IMPORTED_MODULE_7__["BDB_License"].init();
  _modules_media_upload__WEBPACK_IMPORTED_MODULE_8__["BDB_Media"].init();
  _modules_reading_logs__WEBPACK_IMPORTED_MODULE_9__["BDB_Reading_Logs"].init();
  _modules_retailers__WEBPACK_IMPORTED_MODULE_10__["BDB_Retailers"].init();
  _modules_tags__WEBPACK_IMPORTED_MODULE_11__["BDB_Tags"].init();
  _modules_taxonomies_js__WEBPACK_IMPORTED_MODULE_12__["BDB_Book_Taxonomies"].init();
})(jQuery);



/***/ }),

/***/ "./assets/js/src/admin/modules/book-index-title.js":
/*!*********************************************************!*\
  !*** ./assets/js/src/admin/modules/book-index-title.js ***!
  \*********************************************************/
/*! exports provided: BDB_Book_Index_Title */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Book_Index_Title", function() { return BDB_Book_Index_Title; });
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils */ "./assets/js/src/utils/index.js");
/* global $, bdbVars, wp */

var BDB_Book_Index_Title = {
  bookTitleField: false,
  indexTitleSelect: false,
  indexTitleCustomField: false,

  /**
   * Initialize
   */
  init: function init() {
    this.bookTitleField = $('#bdb-book-title');
    this.indexTitleSelect = $('#bdb-book-index-title');
    this.indexTitleCustomField = $('#bdb-book-index-title-custom');
    this.indexTitleSelect.on('change', this.toggleCustomIndexTitle).trigger('change');
    this.bookTitleField.on('keyup', this.writeOriginalTitle);
    this.bookTitleField.on('blur', this.populateIndexTitles);
  },

  /**
   * Show the "Custom" box if "Custom" is selected. Otherwise, hide it.
   */
  toggleCustomIndexTitle: function toggleCustomIndexTitle() {
    var selectedIndexTitle = $(this).val();

    if ('custom' === selectedIndexTitle) {
      BDB_Book_Index_Title.indexTitleCustomField.slideDown().css('display', 'block');
    } else {
      BDB_Book_Index_Title.indexTitleCustomField.slideUp();
    }
  },

  /**
   * Copies the contents of the original "Book Title" field to the "original" index title option.
   */
  writeOriginalTitle: function writeOriginalTitle() {
    BDB_Book_Index_Title.indexTitleSelect.find('option[value="original"]').text($(this).val());
  },

  /**
   * Create an index-friendly version of the entered book title and insert it as an
   * option in the <select> dropdown.
   */
  populateIndexTitles: function populateIndexTitles() {
    var args = {
      title: $(this).val()
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/book/index-title', args, 'GET').then(function (response) {
      BDB_Book_Index_Title.indexTitleSelect.find('option[value="original"]').after('<option value="' + response + '">' + response + '</option>');
    }).catch(function (error) {
      console.log('Index title generation error', error);
    });
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/book-layout.js":
/*!****************************************************!*\
  !*** ./assets/js/src/admin/modules/book-layout.js ***!
  \****************************************************/
/*! exports provided: BDB_Book_Layout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Book_Layout", function() { return BDB_Book_Layout; });
/* global $, bdbVars, wp */

/**
 * Book Layout
 */
var BDB_Book_Layout = {
  /**
   * Initialize
   */
  init: function init() {
    $('.bdb-book-option-toggle').on('click', this.toggleBookTextarea);
    $('#bdb-book-layout-cover-changer').on('change', this.changeCoverAlignment);
    this.sort();
  },

  /**
   * Toggle the book textarea
   *
   * @param e
   */
  toggleBookTextarea: function toggleBookTextarea(e) {
    $(this).next().slideToggle();
  },

  /**
   * Change the real-time alignment of the book coversss123
   *
   * @param e
   */
  changeCoverAlignment: function changeCoverAlignment(e) {
    var parentDiv = $('#bdb-book-option-cover');
    parentDiv.removeClass(function (index, css) {
      return (css.match(/(^|\s)bdb-book-cover-align-\S+/g) || []).join(' ');
    }).addClass('bdb-book-cover-align-' + $(this).val());
  },
  sort: function sort() {
    $('.bdb-sortable').sortable({
      cancel: '.bdb-no-sort, textarea, input, select',
      connectWith: '.bdb-sortable',
      placeholder: 'bdb-sortable-placeholder',
      update: function update(event, ui) {
        var parentID = ui.item.parent().attr('id');
        var disabledIndicator = ui.item.find('.bdb-book-option-disabled');

        if ($('#' + parentID).hasClass('bdb-sorter-enabled-column')) {
          disabledIndicator.val('false');
        } else {
          disabledIndicator.val('true');
        }
      }
    });
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/book-links.js":
/*!***************************************************!*\
  !*** ./assets/js/src/admin/modules/book-links.js ***!
  \***************************************************/
/*! exports provided: BDB_Book_Links */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Book_Links", function() { return BDB_Book_Links; });
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils */ "./assets/js/src/utils/index.js");
/* global $, bdbVars, wp */

/**
 * Book Links
 */

var BDB_Book_Links = {
  bookID: 0,
  linkWrap: false,
  linkTemplateAdd: wp.template('bdb-book-link-add'),
  linkTemplateEdit: wp.template('bdb-book-link-edit'),
  errorWrap: '',

  /**
   * Initialize
   */
  init: function init() {
    this.bookID = $('#bdb-book-id').val();
    this.linkWrap = $('#bdb-book-links');
    this.errorWrap = $('#bdb-book-links-errors');

    if (!this.linkWrap.length) {
      return;
    }

    $('#bdb-new-purchase-link').on('keydown', 'input', this.clickOnEnter);
    $('#bdb-new-purchase-link').on('click', 'button', this.addLink);
    $(document).on('click', '.bdb-update-book-link', this.updateLink);
    $(document).on('click', '.bdb-remove-book-link', this.deleteLink);
    this.getLinks();
  },

  /**
   * Get the links
   */
  getLinks: function getLinks() {
    if (!this.bookID) {
      return;
    }

    var args = {
      book_id: BDB_Book_Links.bookID,
      number: 50
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/book-link', args, 'GET').then(function (apiResponse) {
      BDB_Book_Links.linkWrap.empty();

      if (0 === apiResponse.length || 'undefined' === typeof apiResponse.length) {// Do nothing.
      } else {
        $.each(apiResponse, function (key, link) {
          BDB_Book_Links.linkWrap.append(BDB_Book_Links.linkTemplateEdit(link));
        });
      }
    }).catch(function (error) {
      BDB_Book_Links.errorWrap.empty().append(error).show();
    });
  },

  /**
   * Trigger a button click when pressing `enter` inside an `<input>` field.
   *
   * @param e
   */
  clickOnEnter: function clickOnEnter(e) {
    if (13 === e.keyCode) {
      e.preventDefault();
      $('#bdb-new-purchase-link').find('button').trigger('click');
    }
  },

  /**
   * Add a new link
   *
   * @param e
   */
  addLink: function addLink(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Book_Links.errorWrap.empty().hide();

    if (BDB_Book_Links.bookID) {
      // Editing an existing book.
      var args = {
        book_id: BDB_Book_Links.bookID,
        retailer_id: $('#bdb-new-book-link-retailer').val(),
        url: $('#bdb-new-book-link-url').val()
      };
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/book-link/add', args, 'POST').then(function (apiResponse) {
        BDB_Book_Links.linkWrap.append(BDB_Book_Links.linkTemplateEdit(apiResponse)); // Wipe field values.

        $('#bdb-new-purchase-link').find('input').val('');
        Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
      }).catch(function (errorMessage) {
        BDB_Book_Links.errorWrap.append(errorMessage).show();
        Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
      });
    } else {
      // Adding a new book.
      var data = {
        id: $('.bdb-book-link').length,
        retailer_id: $('#bdb-new-book-link-retailer').val(),
        url: $('#bdb-new-book-link-url').val()
      };
      BDB_Book_Links.linkWrap.append(BDB_Book_Links.linkTemplateAdd(data)); // Wipe field values.

      $('#bdb-new-purchase-link').find('input').val('');
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    }
  },

  /**
   * Update a link
   *
   * @param e
   */
  updateLink: function updateLink(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Book_Links.errorWrap.empty().hide();
    var wrap = button.closest('.bdb-book-link');
    var args = {
      retailer_id: wrap.find('.bdb-book-link-retailer').val(),
      url: wrap.find('.bdb-book-link-url').val()
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/book-link/update/' + wrap.data('id'), args, 'POST').then(function (apiResponse) {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    }).catch(function (errorMessage) {
      BDB_Book_Links.errorWrap.append(errorMessage).show();
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Delete a link
   *
   * @param e
   */
  deleteLink: function deleteLink(e) {
    e.preventDefault();

    if (!confirm(bdbVars.confirm_delete_book_link)) {
      return false;
    }

    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Book_Links.errorWrap.empty().hide();
    var wrap = button.closest('.bdb-book-link');

    if (BDB_Book_Links.bookID) {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/book-link/delete/' + wrap.data('id'), {}, 'DELETE').then(function (apiResponse) {
        wrap.remove();
      }).catch(function (errorMessage) {
        BDB_Book_Links.errorWrap.append(errorMessage).show();
        Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
      });
    } else {
      wrap.remove();
    }
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/categories.js":
/*!***************************************************!*\
  !*** ./assets/js/src/admin/modules/categories.js ***!
  \***************************************************/
/*! exports provided: BDB_Categories */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Categories", function() { return BDB_Categories; });
/* global $, bdbVars, wp */

/**
 * Category style checkboxes
 */
var BDB_Categories = {
  /**
   * Initialize
   */
  init: function init() {
    $('.bdb-new-checkbox-term').on('click', '.button', this.addCheckboxTerm);
    $('.bdb-new-checkbox-term-value').on('keypress', this.addCheckboxTerm);
  },
  addCheckboxTerm: function addCheckboxTerm(e) {
    if ('click' === e.type) {
      e.preventDefault();
    }

    if ('keypress' === e.type && 13 !== e.which) {
      return true;
    } else {
      e.preventDefault();
    }

    var wrap = $(this).closest('.bdb-taxonomy-checkboxes'),
        checkboxName = wrap.data('name'),
        checkboxTaxonomy = wrap.data('taxonomy'),
        checkboxWrap = wrap.find('.bdb-checkbox-wrap'),
        newTerm = wrap.find('.bdb-new-checkbox-term-value'),
        elID = BDB_Categories.createID(newTerm.val(), checkboxTaxonomy + '-');
    checkboxWrap.append('<label for="' + elID + '"><input type="checkbox" id="' + elID + '" name="' + checkboxName + '" class="bdb" value="' + newTerm.val() + '" checked="checked"> ' + newTerm.val() + '</label>');
    newTerm.val('');
  },
  createID: function createID(value, prefix) {
    return value.replace(/[^a-z0-9]/g, function (s) {
      var c = s.charCodeAt(0);

      if (32 === c) {
        return '-';
      }

      if (c >= 65 && c <= 90) {
        return prefix + s.toLowerCase();
      }

      return prefix + ('000' + c.toString(16)).slice(-4);
    });
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/datepicker.js":
/*!***************************************************!*\
  !*** ./assets/js/src/admin/modules/datepicker.js ***!
  \***************************************************/
/*! exports provided: BDB_Datepicker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Datepicker", function() { return BDB_Datepicker; });
/* harmony import */ var flatpickr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatpickr */ "./node_modules/flatpickr/dist/esm/index.js");
/* global $, bdbVars, wp */

/**
 * Datepicker
 */

var BDB_Datepicker = {
  /**
   * Initialize
   */
  init: function init() {
    if ($('.bdb-datepicker').length > 0) {
      this.initDatepickers();
    }

    $(document).on('click', '.bdb-edit-row-with-datepicker', this.maybeAddDatepicker);
  },

  /**
   * Create datepickers
   *
   * altInput is disabled because when it's enabled it breaks the ability to
   * manually delete the input value and have that reflected in the DOM.
   * @link https://github.com/nosegraze/book-database/issues/194
   * @link https://github.com/flatpickr/flatpickr/issues/1910
   *
   * @param {Element} element
   */
  createDatepicker: function createDatepicker(element) {
    var config = {
      allowInput: true,
      dateFormat: 'Y-m-d'
    };

    if (element.classList.contains('bdb-timepicker')) {
      config.enableTime = true;
      config.dateFormat = 'Y-m-d H:i';
      config.altFormat = 'F J, Y, h:i K';
    }

    Object(flatpickr__WEBPACK_IMPORTED_MODULE_0__["default"])(element, config);
  },

  /**
   * Create datepickers for all elements already on the page
   */
  initDatepickers: function initDatepickers() {
    document.querySelectorAll('.bdb-datepicker').forEach(function (element) {
      BDB_Datepicker.createDatepicker(element);
    });
  },

  /**
   * When editing a table row item, find all datepickers within it and initialize them.
   *
   * @param e
   */
  maybeAddDatepicker: function maybeAddDatepicker(e) {
    this.closest('tr').querySelectorAll('.bdb-datepicker').forEach(function (element) {
      var fp = element._flatpickr;

      if ('undefined' === typeof fp) {
        BDB_Datepicker.createDatepicker(element);
      }
    });
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/dates.js":
/*!**********************************************!*\
  !*** ./assets/js/src/admin/modules/dates.js ***!
  \**********************************************/
/*! exports provided: dateUTCtoLocal, dateLocalToUTC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dateUTCtoLocal", function() { return dateUTCtoLocal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dateLocalToUTC", function() { return dateLocalToUTC; });
/* global $, bdbVars, moment */
var formatMySQL = 'YYYY-MM-DD HH:mm:ss';
var formatDisplay = 'MMMM D, YYYY';
/**
 * Converts a UTC date string to local time in YYYY-mm-dd format.
 *
 * @param {string} utcDate
 * @param {string} format
 * @returns {string}
 */

function dateUTCtoLocal(utcDate) {
  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'mysql';

  if ('' === utcDate || !utcDate) {
    return '';
  }

  if ('display' === format) {
    format = formatDisplay;
  } else {
    format = formatMySQL;
  }

  utcDate = moment.utc(utcDate); //console.log( 'UTC Date', utcDate );

  var localDate = utcDate.local().format(format); //console.log( 'Local Date', localDate );

  return localDate;
}
/**
 * Converts a local date string to UTC in YYYY-mm-dd format.
 *
 * @param {string} localDate
 * @returns {string}
 */

function dateLocalToUTC(localDate) {
  if ('' === localDate || !localDate) {
    return '';
  }

  localDate = moment(localDate); //console.log( 'Local Date', localDate );

  var utcDate = localDate.utc().format(formatMySQL); //console.log( 'UTC Date', utcDate );

  return utcDate;
}

/***/ }),

/***/ "./assets/js/src/admin/modules/delete-objects.js":
/*!*******************************************************!*\
  !*** ./assets/js/src/admin/modules/delete-objects.js ***!
  \*******************************************************/
/*! exports provided: BDB_Delete_Objects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Delete_Objects", function() { return BDB_Delete_Objects; });
/* global $, bdbVars, wp */

/**
 * Confirmation when deleting objects
 */
var BDB_Delete_Objects = {
  /**
   * Initialize
   */
  init: function init() {
    $('.bdb-delete-item').on('click', this.confirm);
  },

  /**
   * Confirm deleting the item
   *
   * @param e
   * @returns {boolean}
   */
  confirm: function (_confirm) {
    function confirm(_x) {
      return _confirm.apply(this, arguments);
    }

    confirm.toString = function () {
      return _confirm.toString();
    };

    return confirm;
  }(function (e) {
    var type = $(this).data('object');
    var message = bdbVars['confirm_delete_' + type];

    if (!confirm(message)) {
      return false;
    }

    return true;
  })
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/editions.js":
/*!*************************************************!*\
  !*** ./assets/js/src/admin/modules/editions.js ***!
  \*************************************************/
/*! exports provided: BDB_Editions, fillEditionsDropdown, addEditionToDropdown, removeEditionFromDropdown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Editions", function() { return BDB_Editions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillEditionsDropdown", function() { return fillEditionsDropdown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEditionToDropdown", function() { return addEditionToDropdown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeEditionFromDropdown", function() { return removeEditionFromDropdown; });
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils */ "./assets/js/src/utils/index.js");
/* harmony import */ var _dates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dates */ "./assets/js/src/admin/modules/dates.js");
/* global $, bdbVars, wp */


/**
 * Editions
 */

var BDB_Editions = {
  bookID: 0,
  tableBody: false,
  rowTemplate: wp.template('bdb-editions-table-row'),
  rowEmptyTemplate: wp.template('bdb-editions-table-row-empty'),
  errorWrap: '',

  /**
   * Initialize
   */
  init: function init() {
    this.bookID = $('#bdb-book-id').val();
    this.tableBody = $('#bdb-book-editions-list .wp-list-table tbody');
    this.errorWrap = $('#bdb-editions-errors');

    if (!this.tableBody.length || 'undefined' === typeof this.bookID || !this.bookID) {
      return;
    }

    $('#bdb-add-edition').on('click', this.toggleNewEditionFields);
    $('#bdb-submit-new-edition').on('click', this.addEdition);
    $(document).on('click', '.bdb-edition-toggle-editable', this.toggleEditableFields);
    $(document).on('click', '.bdb-update-edition', this.updateEdition);
    $(document).on('click', '.bdb-remove-edition', this.removeEdition);
    this.getEditions();
  },

  /**
   * Get the editions
   */
  getEditions: function getEditions() {
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/edition', {
      book_id: BDB_Editions.bookID,
      number: 50
    }, 'GET').then(function (response) {
      BDB_Editions.tableBody.empty();

      if (0 === response.length || 'undefined' === typeof response.length) {
        BDB_Editions.tableBody.append(BDB_Editions.rowEmptyTemplate);
      } else {
        $('#bdb-book-editions-empty').remove();
        $.each(response, function (key, edition) {
          edition.date_acquired_formatted = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(edition.date_acquired, 'display');
          edition.date_acquired = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(edition.date_acquired);
          BDB_Editions.tableBody.append(BDB_Editions.rowTemplate(edition));
        });
      }

      $(document).trigger('bdb_editions_loaded');
    }).catch(function (error) {
      BDB_Editions.errorWrap.empty().append(error).show();
    });
  },

  /**
   * Toggle the new edition fields
   *
   * @param e
   */
  toggleNewEditionFields: function toggleNewEditionFields(e) {
    if ('undefined' !== typeof e) {
      e.preventDefault();
    }

    $('#bdb-new-edition-fields').slideToggle();
  },

  /**
   * Add a new edition
   *
   * @param e
   */
  addEdition: function addEdition(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Editions.errorWrap.empty().hide();
    var args = {
      book_id: BDB_Editions.bookID,
      isbn: $('#bdb-new-edition-isbn').val(),
      format: $('#bdb-new-edition-format').val(),
      date_acquired: Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateLocalToUTC"])($('#bdb-new-edition-date-acquired').val()),
      source_id: $('#bdb-checkboxes-source-edition').find('input:checked').val(),
      signed: $('#bdb-new-edition-signed').prop('checked') ? 1 : 0
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/edition/add', args, 'POST').then(function (apiResponse) {
      apiResponse.date_acquired_formatted = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(apiResponse.date_acquired, 'display');
      apiResponse.date_acquired = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(apiResponse.date_acquired);
      $('#bdb-book-editions-empty').remove();
      BDB_Editions.tableBody.append(BDB_Editions.rowTemplate(apiResponse)); // Wipe new field values.

      var newFieldsWrap = $('#bdb-new-edition-fields');
      newFieldsWrap.find('input[type="text"]').val('');
      newFieldsWrap.find('input[type="checkbox"]').prop('checked', false);
      BDB_Editions.toggleNewEditionFields(); // Add this edition to all dropdowns.

      addEditionToDropdown(apiResponse); // Trigger event.

      $(document).trigger('bdb_edition_added', apiResponse);
    }).catch(function (errorMessage) {
      BDB_Editions.errorWrap.append(errorMessage).show();
    }).finally(function () {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Toggle the editable edition fields
   *
   * @param e
   */
  toggleEditableFields: function toggleEditableFields(e) {
    e.preventDefault();
    var button = $(this);
    var wrap = button.closest('tr');
    wrap.find('.bdb-table-display-value').hide();
    wrap.find('.bdb-table-edit-value').show();
    button.removeClass('bdb-edition-toggle-editable').addClass('bdb-update-edition button-primary').text(bdbVars.save);
  },

  /**
   * Update an edition
   *
   * @param e
   */
  updateEdition: function updateEdition(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Editions.errorWrap.empty().hide();
    var wrap = button.closest('tr');
    var args = {
      isbn: wrap.find('.bdb-edition-isbn input').val(),
      format: wrap.find('.bdb-edition-format select').val(),
      date_acquired: Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateLocalToUTC"])(wrap.find('.bdb-edition-date-acquired input').val()),
      source_id: wrap.find('.bdb-edition-source select').val(),
      signed: wrap.find('.bdb-edition-signed input[type="checkbox"]').prop('checked') ? 1 : 0
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/edition/update/' + wrap.data('id'), args, 'POST').then(function (apiResponse) {
      apiResponse.date_acquired_formatted = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(apiResponse.date_acquired, 'display');
      apiResponse.date_acquired = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(apiResponse.date_acquired);
      wrap.replaceWith(BDB_Editions.rowTemplate(apiResponse)); // Update edition in dropdowns.

      addEditionToDropdown(apiResponse);
      $(document).trigger('bdb_edition_updated', apiResponse);
    }).catch(function (errorMessage) {
      BDB_Editions.errorWrap.append(errorMessage).show();
    }).finally(function () {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Delete an edition
   *
   * @param e
   * @returns {boolean}
   */
  removeEdition: function removeEdition(e) {
    e.preventDefault();

    if (!confirm(bdbVars.confirm_delete_edition)) {
      return false;
    }

    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Editions.errorWrap.empty().hide();
    var wrap = button.closest('tr');
    var editionID = wrap.data('id');
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/edition/delete/' + editionID, {}, 'DELETE').then(function (apiResponse) {
      wrap.remove();
      removeEditionFromDropdown(editionID);
    }).catch(function (errorMessage) {
      BDB_Editions.errorWrap.append(errorMessage).show();
    }).finally(function () {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  }
};

/**
 *
 * Fill a provided <select> element with the Edition values
 *
 * @param {object} dropdown
 * @param {Array} editionsArray
 */

function fillEditionsDropdown(dropdown, editionsArray) {
  var selectedEdition = dropdown.data('selected');
  dropdown.empty().append('<option value="">' + bdbVars.none + '</option>');
  $.each(editionsArray, function (key, edition) {
    var selected = edition.id == selectedEdition ? ' selected="selected"' : '';
    dropdown.append('<option value="' + edition.id + '"' + selected + '>' + edition.isbn + ' - ' + edition.format_name + '</option>');
  });
}
/**
 * Add a new edition to the dropdowns
 *
 * @param {object} edition
 */

function addEditionToDropdown(edition) {
  $('.bdb-book-edition-list').each(function () {
    var dropdown = $(this);
    var existingEdition = dropdown.find('option[value="' + edition.id + '"]');

    if (existingEdition.length) {
      existingEdition.text(edition.isbn + ' - ' + edition.format_name);
    } else {
      dropdown.append('<option value="' + edition.id + '">' + edition.isbn + ' - ' + edition.format_name + '</option>');
    }
  });
}
/**
 * Remove an edition from the dropdowns
 *
 * @param {number} editionID
 */

function removeEditionFromDropdown(editionID) {
  $('.bdb-book-edition-list').each(function () {
    var dropdown = $(this);
    dropdown.find('option[value="' + editionID + '"]').remove();
  });
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/license.js":
/*!************************************************!*\
  !*** ./assets/js/src/admin/modules/license.js ***!
  \************************************************/
/*! exports provided: BDB_License */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_License", function() { return BDB_License; });
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils */ "./assets/js/src/utils/index.js");
/* global $, bdbVars, wp, ajaxurl */

/**
 * License Key
 */

var BDB_License = {
  responseWrap: false,

  /**
   * Initialize
   */
  init: function init() {
    this.responseWrap = $('#bdb-license-key-response');
    $('#bdb-activate-license-key').on('click', this.activate);
    $('#bdb-deactivate-license-key').on('click', this.deactivate);
    $('#bdb-refresh-license-key').on('click', this.refresh);
  },

  /**
   * Activate a license key
   *
   * @param e
   */
  activate: function activate(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_License.responseWrap.empty().removeClass('bdb-notice bdb-notice-error');
    var args = {
      action: 'bdb_activate_license_key',
      license_key: $('#bdb-license-key').val(),
      nonce: button.data('nonce')
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["ajaxRequest"])(args).then(function (apiResponse) {
      BDB_License.responseWrap.empty().addClass('bdb-notice bdb-notice-success').append(apiResponse);
      $('#bdb-activate-license-key').remove();
    }).catch(function (errorMessage) {
      BDB_License.responseWrap.empty().addClass('bdb-notice bdb-notice-error').append(errorMessage);
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Deactivate a license key
   *
   * @param e
   */
  deactivate: function deactivate(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_License.responseWrap.empty().removeClass('bdb-notice bdb-notice-error');
    var args = {
      action: 'bdb_deactivate_license_key',
      license_key: $('#bdb-license-key').val(),
      nonce: button.data('nonce')
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["ajaxRequest"])(args).then(function (apiResponse) {
      BDB_License.responseWrap.empty().addClass('bdb-notice bdb-notice-success').append(apiResponse);
      $('#bdb-deactivate-license-key').remove();
    }).catch(function (errorMessage) {
      BDB_License.responseWrap.empty().addClass('bdb-notice bdb-notice-error').append(errorMessage);
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Refresh the license key status
   *
   * @param e
   */
  refresh: function refresh(e) {
    e.preventDefault();
    var button = $(this),
        wrap = button.parent().find('.description');
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_License.responseWrap.empty().removeClass('bdb-notice bdb-notice-error');
    var args = {
      action: 'bdb_refresh_license_key',
      license_key: $('#bdb-license-key').val(),
      nonce: button.data('nonce')
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["ajaxRequest"])(args).then(function (apiResponse) {
      wrap.empty().append(apiResponse);
    }).catch(function (errorMessage) {
      BDB_License.responseWrap.empty().addClass('bdb-notice bdb-notice-error').append(errorMessage);
    }).finally(function () {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/media-upload.js":
/*!*****************************************************!*\
  !*** ./assets/js/src/admin/modules/media-upload.js ***!
  \*****************************************************/
/*! exports provided: BDB_Media */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Media", function() { return BDB_Media; });
/* global $, bdbVars, wp */

/**
 * Interface with the WP media modal
 */
var BDB_Media = {
  frame: false,

  /**
   * Initialize
   */
  init: function init() {
    $('.bdb-upload-image').on('click', this.createFrame);
    $('.bdb-remove-image').on('click', this.removeImage);
  },

  /**
   * Create and open the media frame
   *
   * @param e
   */
  createFrame: function createFrame(e) {
    e.preventDefault();
    var button = $(this),
        imageField = $(this).parent().data('image'),
        imageIDField = $(this).parent().data('image-id'),
        imageSize = $(this).parent().data('image-size');

    if (!imageSize || 'undefined' === typeof imageSize) {
      imageSize = 'medium';
    } // Create the media frame.


    BDB_Media.frame = wp.media.frames.bookDB = wp.media({
      title: button.data('choose'),
      button: {
        text: button.data('update')
      },
      states: [new wp.media.controller.Library({
        title: button.data('choose'),
        filterable: 'all',
        multiple: false
      })]
    }); // When an image is selected, run a callback.

    BDB_Media.frame.on('select', function () {
      var selection = BDB_Media.frame.state().get('selection');
      selection.map(function (attachment) {
        attachment = attachment.toJSON();

        if (attachment.id) {
          $(imageIDField).val(attachment.id);
          var attachmentImage = attachment.sizes && attachment.sizes[imageSize] ? attachment.sizes[imageSize].url : attachment.url; // Remove all image attributes.

          if ('undefined' !== typeof $(imageField).attributes) {
            while ($(imageField).attributes.length > 0) {
              elem.removeAttribute(elem.attributes[0].name);
            }
          } // Update image src and alt text, then show image.


          $(imageField).attr('src', attachmentImage).attr('alt', attachment.alt).show(); // Show remove button.

          button.parent().find('.bdb-remove-image').show();
        }
      });
    }); // Finally, open the modal.

    BDB_Media.frame.open();
  },

  /**
   * Remove the chosen image
   *
   * @param e
   */
  removeImage: function removeImage(e) {
    e.preventDefault();
    var button = $(this),
        imageField = button.parent().data('image'),
        imageIDField = button.parent().data('image-id'); // Remove image attributes and hide.

    if ('undefined' !== typeof $(imageField).attributes) {
      while ($(imageField).attributes.length > 0) {
        elem.removeAttribute(elem.attributes[0].name);
      }
    }

    $(imageField).hide(); // Delete image ID value.

    $(imageIDField).val(''); // Now hide the remove button.

    button.hide();
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/reading-logs.js":
/*!*****************************************************!*\
  !*** ./assets/js/src/admin/modules/reading-logs.js ***!
  \*****************************************************/
/*! exports provided: BDB_Reading_Logs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Reading_Logs", function() { return BDB_Reading_Logs; });
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils */ "./assets/js/src/utils/index.js");
/* harmony import */ var _dates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dates */ "./assets/js/src/admin/modules/dates.js");
/* harmony import */ var _editions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editions */ "./assets/js/src/admin/modules/editions.js");
/* global $, bdbVars, wp */



/**
 * Editions
 */

var BDB_Reading_Logs = {
  bookID: 0,
  userID: 0,
  maxPages: 0,
  tableBody: false,
  rowTemplate: wp.template('bdb-reading-logs-table-row'),
  rowEmptyTemplate: wp.template('bdb-reading-logs-table-row-empty'),
  errorWrap: '',
  userFilter: false,
  editions: [],

  /**
   * Initialize
   */
  init: function init() {
    this.bookID = $('#bdb-book-id').val();
    this.userID = $('#bdb-book-reading-logs-list').data('user-id');
    this.tableBody = $('#bdb-book-reading-logs-list .wp-list-table tbody');
    this.errorWrap = $('#bdb-reading-logs-errors');
    this.userFilter = $('#bdb-book-reading-logs-user-filter');

    if (!this.tableBody.length || 'undefined' === typeof this.bookID || !this.bookID) {
      return;
    }

    this.maxPages = $('#bdb-book-pages').val();
    $('#bdb-add-reading-log').on('click', this.toggleNewLogFields);
    $('#bdb-submit-new-reading-log').on('click', this.addLog);
    $(document).on('click', '.bdb-reading-log-toggle-editable', this.toggleEditableFields);
    $(document).on('click', '.bdb-reading-log-percentage-complete .bdb-input-suffix', this.toggleCompleteUnit);
    $(document).on('click', '.bdb-update-reading-log', this.updateLog);
    $(document).on('click', '.bdb-remove-reading-log', this.removeLog);
    this.userFilter.on('change', this.getLogs);
    this.userFilter.trigger('change'); // Update editions array.

    $(document).on('bdb_edition_added', this.updateEditions);
  },

  /**
   * Set up the object for use in the template
   *
   * - Convert UTC dates to local
   * - Set up the percentage for display (0 - 100)
   *
   * @param {object} readingLog
   * @returns {object}
   */
  shapeObject: function shapeObject(readingLog) {
    readingLog.date_started_formatted = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(readingLog.date_started, 'display');
    readingLog.date_started = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(readingLog.date_started);
    readingLog.date_finished_formatted = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(readingLog.date_finished, 'display');
    readingLog.date_finished = Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateUTCtoLocal"])(readingLog.date_finished);
    readingLog.percentage_complete = (readingLog.percentage_complete * 100).toFixed(0);
    readingLog.rating = null === readingLog.rating ? null : parseFloat(readingLog.rating);
    readingLog.rating_formatted = null === readingLog.rating ? null : parseFloat(readingLog.rating) + ' ' + bdbVars.stars;
    return readingLog;
  },

  /**
   * Load editions
   *
   * @returns {Promise}
   */
  loadEditions: function loadEditions() {
    return Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/edition', {
      book_id: BDB_Reading_Logs.bookID,
      number: 50
    }, 'GET');
  },

  /**
   * Get the reading logs
   */
  getLogs: function getLogs() {
    var args = {
      book_id: BDB_Reading_Logs.bookID,
      number: 50
    };

    if ($('#bdb-book-reading-logs-user-filter').prop('checked')) {
      args.user_id = BDB_Reading_Logs.userID;
    }

    BDB_Reading_Logs.loadEditions().then(function (editions) {
      BDB_Reading_Logs.editions = editions; // Populate editions in "New Log".

      if (BDB_Reading_Logs.editions.length) {
        var selectEditionWrap = $('#bdb-new-log-edition-id-wrap');
        var selectEditionDropdown = $('#bdb-new-log-edition-id');
        selectEditionDropdown.empty().append('<option value="">' + bdbVars.none + '</option>');
        $.each(BDB_Reading_Logs.editions, function (key, edition) {
          selectEditionDropdown.append('<option value="' + edition.id + '">' + edition.isbn + ' - ' + edition.format_name + '</option>');
        });
        selectEditionWrap.show();
      }

      return Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/reading-log', args, 'GET');
    }).then(function (response) {
      BDB_Reading_Logs.tableBody.empty();

      if (0 === response.length || 'undefined' === typeof response.length) {
        BDB_Reading_Logs.tableBody.append(BDB_Reading_Logs.rowEmptyTemplate);
      } else {
        $('#bdb-book-reading-logs-empty').remove();
        $.each(response, function (key, readingLog) {
          readingLog = BDB_Reading_Logs.shapeObject(readingLog);
          BDB_Reading_Logs.tableBody.append(BDB_Reading_Logs.rowTemplate(readingLog));
        });
        BDB_Reading_Logs.tableBody.find('.bdb-book-edition-list').each(function () {
          Object(_editions__WEBPACK_IMPORTED_MODULE_2__["fillEditionsDropdown"])($(this), BDB_Reading_Logs.editions);
        });
      }

      $(document).trigger('bdb_reading_logs_loaded');
    }).catch(function (error) {
      BDB_Reading_Logs.errorWrap.empty().append(error).show();
    });
  },

  /**
   * Toggle the new log fields
   *
   * @param e
   */
  toggleNewLogFields: function toggleNewLogFields(e) {
    if ('undefined' !== typeof e) {
      e.preventDefault();
    }

    $('#bdb-new-reading-log-fields').slideToggle();
  },

  /**
   * Add a new reading log
   *
   * @param e
   */
  addLog: function addLog(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Reading_Logs.errorWrap.empty().hide();
    var percentage = $('#bdb-new-log-percent-complete').val();

    if ('' !== percentage && percentage > 0) {
      percentage = percentage / 100;
    } else {
      percentage = 0;
    }

    var selectedEditionID = $('#bdb-new-log-edition-id').val();
    var args = {
      book_id: BDB_Reading_Logs.bookID,
      edition_id: selectedEditionID.length > 0 ? selectedEditionID : null,
      user_id: BDB_Reading_Logs.userID,
      date_started: Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateLocalToUTC"])($('#bdb-new-log-start-date').val()),
      date_finished: Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateLocalToUTC"])($('#bdb-new-log-end-date').val()),
      percentage_complete: percentage,
      rating: $('#bdb-new-log-rating').val()
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/reading-log/add', args, 'POST').then(function (apiResponse) {
      apiResponse = BDB_Reading_Logs.shapeObject(apiResponse);
      $('#bdb-book-reading-logs-empty').remove();
      BDB_Reading_Logs.tableBody.append(BDB_Reading_Logs.rowTemplate(apiResponse));
      var editionDropdown = $('#bdb-reading-log-edition-id-' + apiResponse.id);

      if (editionDropdown.length) {
        Object(_editions__WEBPACK_IMPORTED_MODULE_2__["fillEditionsDropdown"])(editionDropdown, BDB_Reading_Logs.editions);
      } // Wipe new field values.


      var newFieldsWrap = $('#bdb-new-reading-log-fields');
      newFieldsWrap.find('input[type="text"]').val('');
      newFieldsWrap.find('input[type="checkbox"]').prop('checked', false);
      BDB_Reading_Logs.toggleNewLogFields(); // Trigger event

      $(document).trigger('bdb_reading_log_added', apiResponse);
    }).catch(function (errorMessage) {
      BDB_Reading_Logs.errorWrap.append(errorMessage).show();
    }).finally(function () {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Toggle the editable reading log fields
   *
   * @param e
   */
  toggleEditableFields: function toggleEditableFields(e) {
    e.preventDefault();
    var button = $(this);
    var wrap = button.closest('tr');
    wrap.find('.bdb-table-display-value').hide();
    wrap.find('.bdb-table-edit-value').show();
    button.removeClass('bdb-reading-log-toggle-editable').addClass('bdb-update-reading-log button-primary').text(bdbVars.save);
  },

  /**
   * Toggle the fields for the chosen unit (page vs percentage)
   *
   * @param e
   */
  toggleCompleteUnit: function toggleCompleteUnit(e) {
    e.preventDefault();
    var wrap = $(this).closest('.bdb-reading-log-percentage-complete');
    var type = 'percentage';

    if ($(this).hasClass('bdb-input-suffix-page')) {
      type = 'page';
    } // Change which one is selected.


    wrap.find('.bdb-input-suffix').removeClass('bdb-input-suffix-selected');
    $(this).addClass('bdb-input-suffix-selected'); // Show/hide relevant inputs.

    if ('page' === type) {
      wrap.find('.bdb-reading-log-percentage-complete-wrap').hide();
      wrap.find('.bdb-reading-log-page-wrap').show();
    } else {
      wrap.find('.bdb-reading-log-percentage-complete-wrap').show();
      wrap.find('.bdb-reading-log-page-wrap').hide();
    }
  },

  /**
   * Update a reading log
   *
   * @param e
   */
  updateLog: function updateLog(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Reading_Logs.errorWrap.empty().hide();
    var wrap = button.closest('tr'); // Figure out if we're working with page numbers or percentages.

    var percentage = 0,
        unitType = 'percentage',
        selectedSuffix = wrap.find('.bdb-input-suffix-selected');

    if (selectedSuffix.hasClass('bdb-input-suffix-page')) {
      unitType = 'page';
    }

    if ('page' === unitType) {
      // Page number.
      var pageNumber = wrap.find('.bdb-reading-log-page-wrap input').val();
      percentage = BDB_Reading_Logs.maxPages > 0 ? pageNumber / BDB_Reading_Logs.maxPages : 0;
    } else {
      // Percentage.
      percentage = wrap.find('.bdb-reading-log-percentage-complete-wrap input').val();

      if ('' !== percentage && percentage > 0) {
        percentage = percentage / 100;
      } else {
        percentage = 0;
      }
    }

    var selectedEditionID = wrap.find('.bdb-book-edition-list').val();
    var args = {
      date_started: Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateLocalToUTC"])(wrap.find('.bdb-reading-log-date-started input').val()),
      date_finished: Object(_dates__WEBPACK_IMPORTED_MODULE_1__["dateLocalToUTC"])(wrap.find('.bdb-reading-log-date-finished input').val()),
      edition_id: selectedEditionID.length > 0 ? selectedEditionID : null,
      user_id: wrap.find('.bdb-reading-log-user-id input').val(),
      percentage_complete: percentage,
      rating: wrap.find('.bdb-reading-log-rating select').val()
    };
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/reading-log/update/' + wrap.data('id'), args, 'POST').then(function (apiResponse) {
      apiResponse = BDB_Reading_Logs.shapeObject(apiResponse);
      wrap.replaceWith(BDB_Reading_Logs.rowTemplate(apiResponse));
      var editionDropdown = $('#bdb-reading-log-edition-id-' + apiResponse.id);

      if (editionDropdown.length) {
        Object(_editions__WEBPACK_IMPORTED_MODULE_2__["fillEditionsDropdown"])(editionDropdown, BDB_Reading_Logs.editions);
      }

      $(document).trigger('bdb_reading_log_updated', apiResponse);
    }).catch(function (errorMessage) {
      BDB_Reading_Logs.errorWrap.append(errorMessage).show();
    }).finally(function () {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Delete an edition
   *
   * @param e
   * @returns {boolean}
   */
  removeLog: function removeLog(e) {
    e.preventDefault();

    if (!confirm(bdbVars.confirm_delete_reading_log)) {
      return false;
    }

    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Reading_Logs.errorWrap.empty().hide();
    var wrap = button.closest('tr');
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/reading-log/delete/' + wrap.data('id'), {}, 'DELETE').then(function (apiResponse) {
      wrap.remove();
    }).catch(function (errorMessage) {
      BDB_Reading_Logs.errorWrap.append(errorMessage).show();
    }).finally(function () {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * When a new edition is added, insert it into our array
   *
   * @param e
   * @param {object} newEdition
   */
  updateEditions: function updateEditions(e, newEdition) {
    BDB_Reading_Logs.editions.push(newEdition);
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/retailers.js":
/*!**************************************************!*\
  !*** ./assets/js/src/admin/modules/retailers.js ***!
  \**************************************************/
/*! exports provided: BDB_Retailers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Retailers", function() { return BDB_Retailers; });
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils */ "./assets/js/src/utils/index.js");
/* global $, bdbVars, wp */

/**
 * Retailers
 */

var BDB_Retailers = {
  tableBody: false,
  rowTemplate: wp.template('bdb-retailers-table-row'),
  rowEmptyTemplate: wp.template('bdb-retailers-table-row-empty'),
  errorWrap: '',

  /**
   * Initialize
   */
  init: function init() {
    this.tableBody = $('#bdb-retailers tbody');
    this.errorWrap = $('#bdb-retailers-errors');

    if (!this.tableBody.length) {
      return;
    }

    $('#bdb-new-retailer-fields').on('keydown', 'input', this.clickOnEnter);
    $('#bdb-new-retailer-fields').on('click', 'button', this.addRetailer);
    $(document).on('click', '.bdb-update-retailer', this.updateRetailer);
    $(document).on('click', '.bdb-remove-retailer', this.deleteRetailer);
    this.getRetailers();
  },

  /**
   * Get the list of retailers
   */
  getRetailers: function getRetailers() {
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/retailer', {
      number: 50
    }, 'GET').then(function (response) {
      BDB_Retailers.tableBody.empty();

      if (0 === response.length || 'undefined' === typeof response.length) {
        BDB_Retailers.tableBody.append(BDB_Retailers.rowEmptyTemplate);
      } else {
        $('#bdb-retailers-empty').remove();
        $.each(response, function (key, taxonomy) {
          BDB_Retailers.tableBody.append(BDB_Retailers.rowTemplate(taxonomy));
        });
      }
    }).catch(function (error) {
      BDB_Retailers.errorWrap.empty().append(error).show();
    });
  },

  /**
   * Trigger a button click when pressing `enter` inside an `<input>` field.
   *
   * @param e
   */
  clickOnEnter: function clickOnEnter(e) {
    if (13 === e.keyCode) {
      e.preventDefault();
      $('#bdb-new-retailer-fields').find('button').trigger('click');
    }
  },

  /**
   * Add a new retailer
   *
   * @param e
   */
  addRetailer: function addRetailer(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Retailers.errorWrap.empty().hide();
    var args = {
      name: $('#bdb-new-retailer-name').val(),
      template: $('#bdb-new-retailer-template').val()
    };
    BDB_Retailers.checkRequiredFields(args).then(function (requirementsResponse) {
      return Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/retailer/add', args, 'POST');
    }).then(function (apiResponse) {
      $('#bdb-retailers-empty').remove();
      BDB_Retailers.tableBody.append(BDB_Retailers.rowTemplate(apiResponse)); // Wipe field values.

      $('#bdb-newretailer-fields').find('input').val('');
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    }).catch(function (errorMessage) {
      BDB_Retailers.errorWrap.append(errorMessage).show();
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Update a retailer
   *
   * @param e
   */
  updateRetailer: function updateRetailer(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Retailers.errorWrap.empty().hide();
    var wrap = button.closest('tr');
    var args = {
      name: wrap.find('.bdb-retailer-name input').val(),
      template: wrap.find('.bdb-retailer-template textarea').val()
    };
    BDB_Retailers.checkRequiredFields(args).then(function (requirementsResponse) {
      return Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/retailer/update/' + wrap.data('id'), args, 'POST');
    }).then(function (apiResponse) {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    }).catch(function (errorMessage) {
      BDB_Retailers.errorWrap.append(errorMessage).show();
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Delete a retailer
   *
   * @param e
   * @returns {boolean}
   */
  deleteRetailer: function deleteRetailer(e) {
    e.preventDefault();
    var button = $(this),
        unconfirmed = false;
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Retailers.errorWrap.empty().hide();
    var wrap = button.closest('tr'),
        retailerID = wrap.data('id'),
        confirmMessage = bdbVars.confirm_delete_retailer;
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/book-link', {
      retailer_id: retailerID,
      number: 1
    }, 'GET').then(function (purchaseLinks) {
      if ('undefined' !== typeof purchaseLinks && 'undefined' !== typeof purchaseLinks.length && purchaseLinks.length > 0) {
        confirmMessage = bdbVars.confirm_delete_retailer_links;
      }

      if (!confirm(confirmMessage)) {
        unconfirmed = true;
        throw Error();
      }

      return Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/retailer/delete/' + retailerID, {}, 'DELETE');
    }).then(function (apiResponse) {
      wrap.remove();
    }).catch(function (errorMessage) {
      if (!unconfirmed) {
        BDB_Retailers.errorWrap.append(errorMessage).show();
      }
    }).finally(function () {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Check required fields are filled out
   *
   * @param {object} args
   * @returns {Promise}
   */
  checkRequiredFields: function checkRequiredFields(args) {
    return new Promise(function (resolve, reject) {
      if (!args.hasOwnProperty('name') || '' === args.name) {
        reject(bdbVars.error_required_fields);
        return;
      }

      resolve();
    });
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/tags.js":
/*!*********************************************!*\
  !*** ./assets/js/src/admin/modules/tags.js ***!
  \*********************************************/
/*! exports provided: BDB_Tags */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Tags", function() { return BDB_Tags; });
/* global $, bdbVars, wp */

/**
 * Autocomplete for tags
 */
var BDB_Tags = {
  tag: false,

  /**
   * Initialize
   */
  init: function init() {
    this.tag = $('.bdb-ajaxtag');

    if (!this.tag.length) {
      return;
    }

    $('.bdb-tags-wrap').each(function () {
      BDB_Tags.quickClicks($(this));
    });
    $('.button', BDB_Tags.tag).on('click', function () {
      BDB_Tags.flushTags($(this).closest('.bdb-tags-wrap'));
    });
    BDB_Tags.tag.each(function () {
      var newTag = $('.bdb-new-tag', $(this));
      var taxonomy = $(this).closest('.bdb-tags-wrap').data('taxonomy');
      var apiURL = bdbVars.api_base + 'book-database/v1/book-term/suggest/?taxonomy=' + taxonomy + '&format=text&_wpnonce=' + bdbVars.api_nonce;

      if ('author' === taxonomy) {
        apiURL = bdbVars.api_base + 'book-database/v1/author/suggest/?format=text&_wpnonce=' + bdbVars.api_nonce;
      }

      newTag.on('keyup', function (e) {
        if (13 === e.which) {
          BDB_Tags.flushTags($(this).closest('.bdb-tags-wrap'));
          return false;
        }
      }).on('keypress', function (e) {
        if (13 === e.which) {
          e.preventDefault();
          return false;
        }
      }).suggest(apiURL);
    });
    $('#bdb-book-series-name').suggest(bdbVars.api_base + 'book-database/v1/series/suggest/?format=text&_wpnonce=' + bdbVars.api_nonce); // Save tags on save/publish

    $('.bdb-admin-page > form').on('submit', function (e) {
      $('.bdb-tags-wrap').each(function () {
        BDB_Tags.flushTags(this, false, 1);
      });
    });
  },

  /**
   * Clean tags
   *
   * @param tags
   */
  clean: function clean(tags) {
    return tags.replace(/\s*,\s*/g, ',').replace(/,+/g, ',').replace(/[,\s]+$/, '').replace(/^[,\s]+/, '');
  },

  /**
   * Parse tags
   *
   * @param el
   */
  parseTags: function parseTags(el) {
    var id = el.id;
    var num = id.split('-check-num-')[1];
    var tagBox = $(el).closest('.bdb-tags-wrap');
    var theTags = tagBox.find('textarea');
    var currentTags = theTags.val().split(',');
    var newTags = [];
    delete currentTags[num];
    $.each(currentTags, function (key, val) {
      val = $.trim(val);

      if (val) {
        newTags.push(val);
      }
    });
    theTags.val(BDB_Tags.clean(newTags.join(',')));
    BDB_Tags.quickClicks(tagBox);
    return false;
  },

  /**
   * Handles adding tags
   *
   * @param el
   */
  quickClicks: function quickClicks(el) {
    var theTags = $('textarea', el);
    var tagChecklist = $('.bdb-tags-checklist', el);
    var id = $(el).attr('id');
    var currentTags;
    var disabled;

    if (!theTags.length) {
      return;
    }

    disabled = theTags.prop('disabled');
    currentTags = theTags.val().split(',');
    tagChecklist.empty();
    $.each(currentTags, function (key, val) {
      var span, xbutton;
      val = $.trim(val);

      if (!val) {
        return;
      } // Create a new span and ensure the text is properly escaped.


      span = $('<span />').text(val); // If tags editing isn't disabled, create the X button.

      if (!disabled) {
        xbutton = $('<a id="' + id + '-check-num-' + key + '" class="ntdelbutton">X</a>');
        xbutton.on('click', function (e) {
          BDB_Tags.parseTags(this);
        });
        span.prepend('&nbsp;').prepend(xbutton);
      } // Append the span to the tag list.


      tagChecklist.append(span);
    });
  },

  /**
   * Flush tags on add tag and save
   *
   * @param el
   * @param a
   * @param f
   */
  flushTags: function flushTags(el, a, f) {
    a = a || false;
    var text;
    var tags = $('textarea', el);
    var newTag = $('.bdb-new-tag', el);
    var tagsVal, newTags;
    text = a ? a.text() : newTag.val();
    tagsVal = tags.val();
    newTags = tagsVal ? tagsVal + ',' + text : text;
    newTags = BDB_Tags.clean(newTags);
    newTags = BDB_Tags.uniqueArray(newTags.split(',')).join(',');
    tags.val(newTags);
    BDB_Tags.quickClicks(el);

    if (!a) {
      newTag.val('');
    }

    if ('undefined' === typeof f) {
      newTag.focus();
    }

    return false;
  },

  /**
   * Create a unique array with no empty values
   *
   * @param {array} array
   *
   * @returns {array}
   */
  uniqueArray: function uniqueArray(array) {
    var out = [];
    $.each(array, function (key, val) {
      val = $.trim(val);

      if (val && -1 === $.inArray(val, out)) {
        out.push(val);
      }
    });
    return out;
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/modules/taxonomies.js":
/*!***************************************************!*\
  !*** ./assets/js/src/admin/modules/taxonomies.js ***!
  \***************************************************/
/*! exports provided: BDB_Book_Taxonomies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BDB_Book_Taxonomies", function() { return BDB_Book_Taxonomies; });
/* harmony import */ var utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utils */ "./assets/js/src/utils/index.js");
/* global $, bdbVars, wp */

/**
 * Book Taxonomies
 */

var BDB_Book_Taxonomies = {
  tableBody: false,
  rowTemplate: wp.template('bdb-taxonomies-table-row'),
  rowEmptyTemplate: wp.template('bdb-taxonomies-table-row-empty'),
  errorWrap: '',

  /**
   * Initialize
   */
  init: function init() {
    this.tableBody = $('#bdb-book-taxonomies tbody');
    this.errorWrap = $('#bdb-book-taxonomies-errors');

    if (!this.tableBody.length) {
      return;
    }

    $('#bdb-new-book-taxonomy-name').on('keyup', this.generateSlug);
    $('#bdb-new-book-taxonomy-fields').on('keydown', 'input', this.clickOnEnter);
    $('#bdb-new-book-taxonomy-fields').on('click', '.button-primary', this.addTaxonomy);
    $(document).on('click', '.bdb-update-book-taxonomy', this.updateTaxonomy);
    $(document).on('click', '.bdb-remove-book-taxonomy', this.deleteTaxonomy);
    this.getTaxonomies();
  },

  /**
   * Get the list of taxonomies
   */
  getTaxonomies: function getTaxonomies() {
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/taxonomy', {
      number: 50
    }, 'GET').then(function (response) {
      BDB_Book_Taxonomies.tableBody.empty();

      if (0 === response.length || 'undefined' === typeof response.length) {
        BDB_Book_Taxonomies.tableBody.append(BDB_Book_Taxonomies.rowEmptyTemplate);
      } else {
        $('#bdb-book-taxonomies-empty').remove();
        $.each(response, function (key, taxonomy) {
          BDB_Book_Taxonomies.tableBody.append(BDB_Book_Taxonomies.rowTemplate(taxonomy));
        });
      }
    }).catch(function (error) {
      BDB_Book_Taxonomies.errorWrap.empty().append(error).show();
    });
  },

  /**
   * Automatically generate a slug from the name
   *
   * @param e
   */
  generateSlug: function generateSlug(e) {
    var name = $('#bdb-new-book-taxonomy-name').val();
    var slug = name.toLowerCase().replace(/[^a-z0-9_\-]/g, '');
    $('#bdb-new-book-taxonomy-slug').val(slug);
  },

  /**
   * Trigger a button click when pressing `enter` inside an `<input>` field.
   *
   * @param e
   */
  clickOnEnter: function clickOnEnter(e) {
    if (13 === e.keyCode) {
      e.preventDefault();
      $('#bdb-new-book-taxonomy-fields').find('button').trigger('click');
    }
  },

  /**
   * Add a new taxonomy
   *
   * @param e
   */
  addTaxonomy: function addTaxonomy(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Book_Taxonomies.errorWrap.empty().hide();
    var args = {
      name: $('#bdb-new-book-taxonomy-name').val(),
      slug: $('#bdb-new-book-taxonomy-slug').val(),
      format: $('#bdb-new-book-taxonomy-format').val()
    };
    BDB_Book_Taxonomies.checkRequiredFields(args).then(function (requirementsResponse) {
      return Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/taxonomy/add', args, 'POST');
    }).then(function (apiResponse) {
      $('#bdb-book-taxonomies-empty').remove();
      BDB_Book_Taxonomies.tableBody.append(BDB_Book_Taxonomies.rowTemplate(apiResponse)); // Wipe field values.

      $('#bdb-new-book-taxonomy-fields').find('input').val('');
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    }).catch(function (errorMessage) {
      BDB_Book_Taxonomies.errorWrap.append(errorMessage).show();
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Update a taxonomy
   *
   * @param e
   */
  updateTaxonomy: function updateTaxonomy(e) {
    e.preventDefault();
    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Book_Taxonomies.errorWrap.empty().hide();
    var wrap = button.closest('tr');
    var args = {
      name: wrap.find('.bdb-book-taxonomy-name input').val(),
      slug: wrap.find('.bdb-book-taxonomy-slug input').val(),
      format: wrap.find('.bdb-book-taxonomy-format select').val()
    };
    BDB_Book_Taxonomies.checkRequiredFields(args).then(function (requirementsResponse) {
      return Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/taxonomy/update/' + wrap.data('id'), args, 'POST');
    }).then(function (apiResponse) {
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    }).catch(function (errorMessage) {
      BDB_Book_Taxonomies.errorWrap.append(errorMessage).show();
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Delete a taxonomy
   *
   * @param e
   * @returns {boolean}
   */
  deleteTaxonomy: function deleteTaxonomy(e) {
    e.preventDefault();

    if (!confirm(bdbVars.confirm_delete_taxonomy)) {
      return false;
    }

    var button = $(this);
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["spinButton"])(button);
    BDB_Book_Taxonomies.errorWrap.empty().hide();
    var wrap = button.closest('tr');
    Object(utils__WEBPACK_IMPORTED_MODULE_0__["apiRequest"])('v1/taxonomy/delete/' + wrap.data('id'), {}, 'DELETE').then(function (apiResponse) {
      wrap.remove();
    }).catch(function (errorMessage) {
      BDB_Book_Taxonomies.errorWrap.append(errorMessage).show();
      Object(utils__WEBPACK_IMPORTED_MODULE_0__["unspinButton"])(button);
    });
  },

  /**
   * Check required fields are filled out
   *
   * @param {object} args
   * @returns {Promise}
   */
  checkRequiredFields: function checkRequiredFields(args) {
    return new Promise(function (resolve, reject) {
      if (!args.hasOwnProperty('name') || '' === args.name) {
        reject(bdbVars.error_required_fields);
        return;
      }

      if (!args.hasOwnProperty('slug') || '' === args.slug) {
        reject(bdbVars.error_required_fields);
        return;
      }

      if (!args.hasOwnProperty('format') || '' === args.format) {
        reject(bdbVars.error_required_fields);
        return;
      }

      resolve();
    });
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/admin/utils/edit-display-toggle.js":
/*!**********************************************************!*\
  !*** ./assets/js/src/admin/utils/edit-display-toggle.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return toggleDisplayAndEditFields; });
/**
 * Toggles the display and edit fields off/on within a wrapper.
 *
 * @param {HTMLElement} wrapper
 * @param {boolean} isEditMode
 */
function toggleDisplayAndEditFields(wrapper, isEditMode) {
  var displayValues = wrapper.querySelectorAll('.bdb-table-display-value');
  var editValues = wrapper.querySelectorAll('.bdb-table-edit-value');

  if (displayValues) {
    displayValues.forEach(function (el) {
      el.style.display = isEditMode ? 'none' : 'block';
    });
  }

  if (editValues) {
    editValues.forEach(function (el) {
      el.style.display = isEditMode ? 'block' : 'none';
    });
  }
}

/***/ }),

/***/ "./assets/js/src/utils/api-request.js":
/*!********************************************!*\
  !*** ./assets/js/src/utils/api-request.js ***!
  \********************************************/
/*! exports provided: apiRequest, ajaxRequest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apiRequest", function() { return apiRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ajaxRequest", function() { return ajaxRequest; });
/* global $, bdbVars, ajaxurl */

/**
 * Make a request to the REST API
 *
 * @param {string} endpoint
 * @param {object} data
 * @param {string} method
 * @returns {Promise}
 */
function apiRequest(endpoint) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'POST';
  var options = {
    method: method,
    url: bdbVars.api_base + 'book-database/' + endpoint,
    beforeSend: function beforeSend(xhr) {
      xhr.setRequestHeader('X-WP-Nonce', bdbVars.api_nonce);
    },
    xhrFields: {
      withCredentials: true
    },
    data: data
  }; //console.log( 'API endpoint', endpoint );

  return new Promise(function (resolve, reject) {
    $.ajax(options).success(function (response) {
      //console.log( 'Success response', response );
      resolve(response);
    }).error(function (qpXHR, textStatus, errorThrown) {
      var error = bdbVars.generic_erroc;

      if ('undefined' !== typeof qpXHR.responseJSON) {
        error = qpXHR.responseJSON;

        if ('undefined' !== typeof error.message) {
          error = error.message;
        }
      } else if ('undefined' !== typeof qpXHR.message) {
        error = qpXHR.message;
      }

      reject(error);
    });
  });
}
/**
 * Make an ajax request
 *
 * @param {object} args
 * @returns {Promise}
 */

function ajaxRequest(args) {
  var options = {
    method: 'POST',
    dataType: 'JSON',
    url: ajaxurl,
    data: args
  };
  return new Promise(function (resolve, reject) {
    $.ajax(options).success(function (response) {
      if (!response.success) {
        //console.log( 'Error response', response );
        reject(response.data);
      } else {
        //console.log( 'Success response', response );
        resolve(response.data);
      }
    }).error(function (qpXHR, textStatus, errorThrown) {
      var error = bdbVars.generic_erroc;

      if ('undefined' !== typeof qpXHR.responseJSON) {
        error = qpXHR.responseJSON;

        if ('undefined' !== typeof error.message) {
          error = error.message;
        }
      } else if ('undefined' !== typeof qpXHR.message) {
        error = qpXHR.message;
      }

      reject(error);
    });
  });
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./assets/js/src/utils/index.js":
/*!**************************************!*\
  !*** ./assets/js/src/utils/index.js ***!
  \**************************************/
/*! exports provided: apiRequest, ajaxRequest, spinButton, unspinButton, getStars */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _api_request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api-request.js */ "./assets/js/src/utils/api-request.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "apiRequest", function() { return _api_request_js__WEBPACK_IMPORTED_MODULE_0__["apiRequest"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ajaxRequest", function() { return _api_request_js__WEBPACK_IMPORTED_MODULE_0__["ajaxRequest"]; });

/* harmony import */ var _loaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loaders.js */ "./assets/js/src/utils/loaders.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "spinButton", function() { return _loaders_js__WEBPACK_IMPORTED_MODULE_1__["spinButton"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unspinButton", function() { return _loaders_js__WEBPACK_IMPORTED_MODULE_1__["unspinButton"]; });

/* harmony import */ var _ratings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ratings.js */ "./assets/js/src/utils/ratings.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStars", function() { return _ratings_js__WEBPACK_IMPORTED_MODULE_2__["getStars"]; });





/***/ }),

/***/ "./assets/js/src/utils/loaders.js":
/*!****************************************!*\
  !*** ./assets/js/src/utils/loaders.js ***!
  \****************************************/
/*! exports provided: spinButton, unspinButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spinButton", function() { return spinButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unspinButton", function() { return unspinButton; });
/* global $, bdbVars */

/**
 * Spin a button
 *
 *      - Disables the button
 *      - Saves the current button text to `data-text`
 *      - Changes the text to either a WP-Admin spinner or "Please Wait..."
 *
 * @param button
 */
function spinButton(button) {
  var newText = bdbVars.is_admin ? '<span class="spinner is-active"></span>' : bdbVars.please_wait;
  button.prop('disabled', true).data('text', button.text()).html(newText);
}
/**
 * Unspin a button
 *
 *      - Enables teh button
 *      - Sets the text to the `data-text` attribute value
 *
 * @param button
 */

function unspinButton(button) {
  button.prop('disabled', false).text(button.data('text'));
}

/***/ }),

/***/ "./assets/js/src/utils/ratings.js":
/*!****************************************!*\
  !*** ./assets/js/src/utils/ratings.js ***!
  \****************************************/
/*! exports provided: getStars */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStars", function() { return getStars; });
/* global $, bdbVars */

/**
 * Convert a numberical star rating into HTML stars
 *
 * @param rating
 * @returns {string}
 */
function getStars(rating) {
  var html = '';
  var fullStars = Math.floor(rating);
  var halfStars = Math.ceil(rating - fullStars);
  var fullStarString = '&starf;';
  var halfStarString = '&half;';
  html += fullStarString.repeat(fullStars);
  html += halfStarString.repeat(halfStars);
  return html;
}

/***/ }),

/***/ "./node_modules/flatpickr/dist/esm/index.js":
/*!**************************************************!*\
  !*** ./node_modules/flatpickr/dist/esm/index.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _types_options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types/options */ "./node_modules/flatpickr/dist/esm/types/options.js");
/* harmony import */ var _l10n_default__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./l10n/default */ "./node_modules/flatpickr/dist/esm/l10n/default.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./node_modules/flatpickr/dist/esm/utils/index.js");
/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/dom */ "./node_modules/flatpickr/dist/esm/utils/dom.js");
/* harmony import */ var _utils_dates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/dates */ "./node_modules/flatpickr/dist/esm/utils/dates.js");
/* harmony import */ var _utils_formatting__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/formatting */ "./node_modules/flatpickr/dist/esm/utils/formatting.js");
/* harmony import */ var _utils_polyfills__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/polyfills */ "./node_modules/flatpickr/dist/esm/utils/polyfills.js");
/* harmony import */ var _utils_polyfills__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_utils_polyfills__WEBPACK_IMPORTED_MODULE_6__);







const DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
    const self = {
        config: Object.assign(Object.assign({}, _types_options__WEBPACK_IMPORTED_MODULE_0__["defaults"]), flatpickr.defaultConfig),
        l10n: _l10n_default__WEBPACK_IMPORTED_MODULE_1__["default"],
    };
    self.parseDate = Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["createDateParser"])({ config: self.config, l10n: self.l10n });
    self._handlers = [];
    self.pluginElements = [];
    self.loadedPlugins = [];
    self._bind = bind;
    self._setHoursFromDate = setHoursFromDate;
    self._positionCalendar = positionCalendar;
    self.changeMonth = changeMonth;
    self.changeYear = changeYear;
    self.clear = clear;
    self.close = close;
    self._createElement = _utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"];
    self.destroy = destroy;
    self.isEnabled = isEnabled;
    self.jumpToDate = jumpToDate;
    self.open = open;
    self.redraw = redraw;
    self.set = set;
    self.setDate = setDate;
    self.toggle = toggle;
    function setupHelperFunctions() {
        self.utils = {
            getDaysInMonth(month = self.currentMonth, yr = self.currentYear) {
                if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                    return 29;
                return self.l10n.daysInMonth[month];
            },
        };
    }
    function init() {
        self.element = self.input = element;
        self.isOpen = false;
        parseConfig();
        setupLocale();
        setupInputs();
        setupDates();
        setupHelperFunctions();
        if (!self.isMobile)
            build();
        bindEvents();
        if (self.selectedDates.length || self.config.noCalendar) {
            if (self.config.enableTime) {
                setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : undefined);
            }
            updateValue(false);
        }
        setCalendarWidth();
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if (!self.isMobile && isSafari) {
            positionCalendar();
        }
        triggerEvent("onReady");
    }
    function bindToInstance(fn) {
        return fn.bind(self);
    }
    function setCalendarWidth() {
        const config = self.config;
        if (config.weekNumbers === false && config.showMonths === 1) {
            return;
        }
        else if (config.noCalendar !== true) {
            window.requestAnimationFrame(function () {
                if (self.calendarContainer !== undefined) {
                    self.calendarContainer.style.visibility = "hidden";
                    self.calendarContainer.style.display = "block";
                }
                if (self.daysContainer !== undefined) {
                    const daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                    self.daysContainer.style.width = daysWidth + "px";
                    self.calendarContainer.style.width =
                        daysWidth +
                            (self.weekWrapper !== undefined
                                ? self.weekWrapper.offsetWidth
                                : 0) +
                            "px";
                    self.calendarContainer.style.removeProperty("visibility");
                    self.calendarContainer.style.removeProperty("display");
                }
            });
        }
    }
    function updateTime(e) {
        if (self.selectedDates.length === 0) {
            const defaultDate = self.config.minDate === undefined ||
                Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(new Date(), self.config.minDate) >= 0
                ? new Date()
                : new Date(self.config.minDate.getTime());
            const defaults = Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["getDefaultHours"])(self.config);
            defaultDate.setHours(defaults.hours, defaults.minutes, defaults.seconds, defaultDate.getMilliseconds());
            self.selectedDates = [defaultDate];
            self.latestSelectedDateObj = defaultDate;
        }
        if (e !== undefined && e.type !== "blur") {
            timeWrapper(e);
        }
        const prevValue = self._input.value;
        setHoursFromInputs();
        updateValue();
        if (self._input.value !== prevValue) {
            self._debouncedChange();
        }
    }
    function ampm2military(hour, amPM) {
        return (hour % 12) + 12 * Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])(amPM === self.l10n.amPM[1]);
    }
    function military2ampm(hour) {
        switch (hour % 24) {
            case 0:
            case 12:
                return 12;
            default:
                return hour % 12;
        }
    }
    function setHoursFromInputs() {
        if (self.hourElement === undefined || self.minuteElement === undefined)
            return;
        let hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
            ? (parseInt(self.secondElement.value, 10) || 0) % 60
            : 0;
        if (self.amPM !== undefined) {
            hours = ampm2military(hours, self.amPM.textContent);
        }
        const limitMinHours = self.config.minTime !== undefined ||
            (self.config.minDate &&
                self.minDateHasTime &&
                self.latestSelectedDateObj &&
                Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(self.latestSelectedDateObj, self.config.minDate, true) ===
                    0);
        const limitMaxHours = self.config.maxTime !== undefined ||
            (self.config.maxDate &&
                self.maxDateHasTime &&
                self.latestSelectedDateObj &&
                Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(self.latestSelectedDateObj, self.config.maxDate, true) ===
                    0);
        if (limitMaxHours) {
            const maxTime = self.config.maxTime !== undefined
                ? self.config.maxTime
                : self.config.maxDate;
            hours = Math.min(hours, maxTime.getHours());
            if (hours === maxTime.getHours())
                minutes = Math.min(minutes, maxTime.getMinutes());
            if (minutes === maxTime.getMinutes())
                seconds = Math.min(seconds, maxTime.getSeconds());
        }
        if (limitMinHours) {
            const minTime = self.config.minTime !== undefined
                ? self.config.minTime
                : self.config.minDate;
            hours = Math.max(hours, minTime.getHours());
            if (hours === minTime.getHours() && minutes < minTime.getMinutes())
                minutes = minTime.getMinutes();
            if (minutes === minTime.getMinutes())
                seconds = Math.max(seconds, minTime.getSeconds());
        }
        setHours(hours, minutes, seconds);
    }
    function setHoursFromDate(dateObj) {
        const date = dateObj || self.latestSelectedDateObj;
        if (date) {
            setHours(date.getHours(), date.getMinutes(), date.getSeconds());
        }
    }
    function setHours(hours, minutes, seconds) {
        if (self.latestSelectedDateObj !== undefined) {
            self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
        }
        if (!self.hourElement || !self.minuteElement || self.isMobile)
            return;
        self.hourElement.value = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["pad"])(!self.config.time_24hr
            ? ((12 + hours) % 12) + 12 * Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])(hours % 12 === 0)
            : hours);
        self.minuteElement.value = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["pad"])(minutes);
        if (self.amPM !== undefined)
            self.amPM.textContent = self.l10n.amPM[Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])(hours >= 12)];
        if (self.secondElement !== undefined)
            self.secondElement.value = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["pad"])(seconds);
    }
    function onYearInput(event) {
        const eventTarget = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(event);
        const year = parseInt(eventTarget.value) + (event.delta || 0);
        if (year / 1000 > 1 ||
            (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
            changeYear(year);
        }
    }
    function bind(element, event, handler, options) {
        if (event instanceof Array)
            return event.forEach((ev) => bind(element, ev, handler, options));
        if (element instanceof Array)
            return element.forEach((el) => bind(el, event, handler, options));
        element.addEventListener(event, handler, options);
        self._handlers.push({
            remove: () => element.removeEventListener(event, handler),
        });
    }
    function triggerChange() {
        triggerEvent("onChange");
    }
    function bindEvents() {
        if (self.config.wrap) {
            ["open", "close", "toggle", "clear"].forEach((evt) => {
                Array.prototype.forEach.call(self.element.querySelectorAll(`[data-${evt}]`), (el) => bind(el, "click", self[evt]));
            });
        }
        if (self.isMobile) {
            setupMobile();
            return;
        }
        const debouncedResize = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["debounce"])(onResize, 50);
        self._debouncedChange = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["debounce"])(triggerChange, DEBOUNCED_CHANGE_MS);
        if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
            bind(self.daysContainer, "mouseover", (e) => {
                if (self.config.mode === "range")
                    onMouseOver(Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e));
            });
        bind(window.document.body, "keydown", onKeyDown);
        if (!self.config.inline && !self.config.static)
            bind(window, "resize", debouncedResize);
        if (window.ontouchstart !== undefined)
            bind(window.document, "touchstart", documentClick);
        else
            bind(window.document, "mousedown", documentClick);
        bind(window.document, "focus", documentClick, { capture: true });
        if (self.config.clickOpens === true) {
            bind(self._input, "focus", self.open);
            bind(self._input, "click", self.open);
        }
        if (self.daysContainer !== undefined) {
            bind(self.monthNav, "click", onMonthNavClick);
            bind(self.monthNav, ["keyup", "increment"], onYearInput);
            bind(self.daysContainer, "click", selectDate);
        }
        if (self.timeContainer !== undefined &&
            self.minuteElement !== undefined &&
            self.hourElement !== undefined) {
            const selText = (e) => Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e).select();
            bind(self.timeContainer, ["increment"], updateTime);
            bind(self.timeContainer, "blur", updateTime, { capture: true });
            bind(self.timeContainer, "click", timeIncrement);
            bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
            if (self.secondElement !== undefined)
                bind(self.secondElement, "focus", () => self.secondElement && self.secondElement.select());
            if (self.amPM !== undefined) {
                bind(self.amPM, "click", (e) => {
                    updateTime(e);
                    triggerChange();
                });
            }
        }
        if (self.config.allowInput) {
            bind(self._input, "blur", onBlur);
        }
    }
    function jumpToDate(jumpDate, triggerChange) {
        const jumpTo = jumpDate !== undefined
            ? self.parseDate(jumpDate)
            : self.latestSelectedDateObj ||
                (self.config.minDate && self.config.minDate > self.now
                    ? self.config.minDate
                    : self.config.maxDate && self.config.maxDate < self.now
                        ? self.config.maxDate
                        : self.now);
        const oldYear = self.currentYear;
        const oldMonth = self.currentMonth;
        try {
            if (jumpTo !== undefined) {
                self.currentYear = jumpTo.getFullYear();
                self.currentMonth = jumpTo.getMonth();
            }
        }
        catch (e) {
            e.message = "Invalid date supplied: " + jumpTo;
            self.config.errorHandler(e);
        }
        if (triggerChange && self.currentYear !== oldYear) {
            triggerEvent("onYearChange");
            buildMonthSwitch();
        }
        if (triggerChange &&
            (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
            triggerEvent("onMonthChange");
        }
        self.redraw();
    }
    function timeIncrement(e) {
        const eventTarget = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e);
        if (~eventTarget.className.indexOf("arrow"))
            incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    function incrementNumInput(e, delta, inputElem) {
        const target = e && Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e);
        const input = inputElem ||
            (target && target.parentNode && target.parentNode.firstChild);
        const event = createEvent("increment");
        event.delta = delta;
        input && input.dispatchEvent(event);
    }
    function build() {
        const fragment = window.document.createDocumentFragment();
        self.calendarContainer = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-calendar");
        self.calendarContainer.tabIndex = -1;
        if (!self.config.noCalendar) {
            fragment.appendChild(buildMonthNav());
            self.innerContainer = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-innerContainer");
            if (self.config.weekNumbers) {
                const { weekWrapper, weekNumbers } = buildWeeks();
                self.innerContainer.appendChild(weekWrapper);
                self.weekNumbers = weekNumbers;
                self.weekWrapper = weekWrapper;
            }
            self.rContainer = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-rContainer");
            self.rContainer.appendChild(buildWeekdays());
            if (!self.daysContainer) {
                self.daysContainer = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-days");
                self.daysContainer.tabIndex = -1;
            }
            buildDays();
            self.rContainer.appendChild(self.daysContainer);
            self.innerContainer.appendChild(self.rContainer);
            fragment.appendChild(self.innerContainer);
        }
        if (self.config.enableTime) {
            fragment.appendChild(buildTime());
        }
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "rangeMode", self.config.mode === "range");
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "animate", self.config.animate === true);
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
        self.calendarContainer.appendChild(fragment);
        const customAppend = self.config.appendTo !== undefined &&
            self.config.appendTo.nodeType !== undefined;
        if (self.config.inline || self.config.static) {
            self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
            if (self.config.inline) {
                if (!customAppend && self.element.parentNode)
                    self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                else if (self.config.appendTo !== undefined)
                    self.config.appendTo.appendChild(self.calendarContainer);
            }
            if (self.config.static) {
                const wrapper = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-wrapper");
                if (self.element.parentNode)
                    self.element.parentNode.insertBefore(wrapper, self.element);
                wrapper.appendChild(self.element);
                if (self.altInput)
                    wrapper.appendChild(self.altInput);
                wrapper.appendChild(self.calendarContainer);
            }
        }
        if (!self.config.static && !self.config.inline)
            (self.config.appendTo !== undefined
                ? self.config.appendTo
                : window.document.body).appendChild(self.calendarContainer);
    }
    function createDay(className, date, dayNumber, i) {
        const dateIsEnabled = isEnabled(date, true), dayElement = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("span", "flatpickr-day " + className, date.getDate().toString());
        dayElement.dateObj = date;
        dayElement.$i = i;
        dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
        if (className.indexOf("hidden") === -1 &&
            Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(date, self.now) === 0) {
            self.todayDateElem = dayElement;
            dayElement.classList.add("today");
            dayElement.setAttribute("aria-current", "date");
        }
        if (dateIsEnabled) {
            dayElement.tabIndex = -1;
            if (isDateSelected(date)) {
                dayElement.classList.add("selected");
                self.selectedDateElem = dayElement;
                if (self.config.mode === "range") {
                    Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(dayElement, "startRange", self.selectedDates[0] &&
                        Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(date, self.selectedDates[0], true) === 0);
                    Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(dayElement, "endRange", self.selectedDates[1] &&
                        Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(date, self.selectedDates[1], true) === 0);
                    if (className === "nextMonthDay")
                        dayElement.classList.add("inRange");
                }
            }
        }
        else {
            dayElement.classList.add("flatpickr-disabled");
        }
        if (self.config.mode === "range") {
            if (isDateInRange(date) && !isDateSelected(date))
                dayElement.classList.add("inRange");
        }
        if (self.weekNumbers &&
            self.config.showMonths === 1 &&
            className !== "prevMonthDay" &&
            dayNumber % 7 === 1) {
            self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
        }
        triggerEvent("onDayCreate", dayElement);
        return dayElement;
    }
    function focusOnDayElem(targetNode) {
        targetNode.focus();
        if (self.config.mode === "range")
            onMouseOver(targetNode);
    }
    function getFirstAvailableDay(delta) {
        const startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
        const endMonth = delta > 0 ? self.config.showMonths : -1;
        for (let m = startMonth; m != endMonth; m += delta) {
            const month = self.daysContainer.children[m];
            const startIndex = delta > 0 ? 0 : month.children.length - 1;
            const endIndex = delta > 0 ? month.children.length : -1;
            for (let i = startIndex; i != endIndex; i += delta) {
                const c = month.children[i];
                if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                    return c;
            }
        }
        return undefined;
    }
    function getNextAvailableDay(current, delta) {
        const givenMonth = current.className.indexOf("Month") === -1
            ? current.dateObj.getMonth()
            : self.currentMonth;
        const endMonth = delta > 0 ? self.config.showMonths : -1;
        const loopDelta = delta > 0 ? 1 : -1;
        for (let m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
            const month = self.daysContainer.children[m];
            const startIndex = givenMonth - self.currentMonth === m
                ? current.$i + delta
                : delta < 0
                    ? month.children.length - 1
                    : 0;
            const numMonthDays = month.children.length;
            for (let i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                const c = month.children[i];
                if (c.className.indexOf("hidden") === -1 &&
                    isEnabled(c.dateObj) &&
                    Math.abs(current.$i - i) >= Math.abs(delta))
                    return focusOnDayElem(c);
            }
        }
        self.changeMonth(loopDelta);
        focusOnDay(getFirstAvailableDay(loopDelta), 0);
        return undefined;
    }
    function focusOnDay(current, offset) {
        const dayFocused = isInView(document.activeElement || document.body);
        const startElem = current !== undefined
            ? current
            : dayFocused
                ? document.activeElement
                : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                    ? self.selectedDateElem
                    : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                        ? self.todayDateElem
                        : getFirstAvailableDay(offset > 0 ? 1 : -1);
        if (startElem === undefined) {
            self._input.focus();
        }
        else if (!dayFocused) {
            focusOnDayElem(startElem);
        }
        else {
            getNextAvailableDay(startElem, offset);
        }
    }
    function buildMonthDays(year, month) {
        const firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
        const prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
        const daysInMonth = self.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
        let dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
        for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
            days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
        }
        for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
            days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
        }
        for (let dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
            (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
            days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
        }
        const dayContainer = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "dayContainer");
        dayContainer.appendChild(days);
        return dayContainer;
    }
    function buildDays() {
        if (self.daysContainer === undefined) {
            return;
        }
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["clearNode"])(self.daysContainer);
        if (self.weekNumbers)
            Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["clearNode"])(self.weekNumbers);
        const frag = document.createDocumentFragment();
        for (let i = 0; i < self.config.showMonths; i++) {
            const d = new Date(self.currentYear, self.currentMonth, 1);
            d.setMonth(self.currentMonth + i);
            frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
        }
        self.daysContainer.appendChild(frag);
        self.days = self.daysContainer.firstChild;
        if (self.config.mode === "range" && self.selectedDates.length === 1) {
            onMouseOver();
        }
    }
    function buildMonthSwitch() {
        if (self.config.showMonths > 1 ||
            self.config.monthSelectorType !== "dropdown")
            return;
        const shouldBuildMonth = function (month) {
            if (self.config.minDate !== undefined &&
                self.currentYear === self.config.minDate.getFullYear() &&
                month < self.config.minDate.getMonth()) {
                return false;
            }
            return !(self.config.maxDate !== undefined &&
                self.currentYear === self.config.maxDate.getFullYear() &&
                month > self.config.maxDate.getMonth());
        };
        self.monthsDropdownContainer.tabIndex = -1;
        self.monthsDropdownContainer.innerHTML = "";
        for (let i = 0; i < 12; i++) {
            if (!shouldBuildMonth(i))
                continue;
            const month = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("option", "flatpickr-monthDropdown-month");
            month.value = new Date(self.currentYear, i).getMonth().toString();
            month.textContent = Object(_utils_formatting__WEBPACK_IMPORTED_MODULE_5__["monthToStr"])(i, self.config.shorthandCurrentMonth, self.l10n);
            month.tabIndex = -1;
            if (self.currentMonth === i) {
                month.selected = true;
            }
            self.monthsDropdownContainer.appendChild(month);
        }
    }
    function buildMonth() {
        const container = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-month");
        const monthNavFragment = window.document.createDocumentFragment();
        let monthElement;
        if (self.config.showMonths > 1 ||
            self.config.monthSelectorType === "static") {
            monthElement = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("span", "cur-month");
        }
        else {
            self.monthsDropdownContainer = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("select", "flatpickr-monthDropdown-months");
            self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
            bind(self.monthsDropdownContainer, "change", (e) => {
                const target = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e);
                const selectedMonth = parseInt(target.value, 10);
                self.changeMonth(selectedMonth - self.currentMonth);
                triggerEvent("onMonthChange");
            });
            buildMonthSwitch();
            monthElement = self.monthsDropdownContainer;
        }
        const yearInput = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createNumberInput"])("cur-year", { tabindex: "-1" });
        const yearElement = yearInput.getElementsByTagName("input")[0];
        yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
        if (self.config.minDate) {
            yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
        }
        if (self.config.maxDate) {
            yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
            yearElement.disabled =
                !!self.config.minDate &&
                    self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
        }
        const currentMonth = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-current-month");
        currentMonth.appendChild(monthElement);
        currentMonth.appendChild(yearInput);
        monthNavFragment.appendChild(currentMonth);
        container.appendChild(monthNavFragment);
        return {
            container,
            yearElement,
            monthElement,
        };
    }
    function buildMonths() {
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["clearNode"])(self.monthNav);
        self.monthNav.appendChild(self.prevMonthNav);
        if (self.config.showMonths) {
            self.yearElements = [];
            self.monthElements = [];
        }
        for (let m = self.config.showMonths; m--;) {
            const month = buildMonth();
            self.yearElements.push(month.yearElement);
            self.monthElements.push(month.monthElement);
            self.monthNav.appendChild(month.container);
        }
        self.monthNav.appendChild(self.nextMonthNav);
    }
    function buildMonthNav() {
        self.monthNav = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-months");
        self.yearElements = [];
        self.monthElements = [];
        self.prevMonthNav = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("span", "flatpickr-prev-month");
        self.prevMonthNav.innerHTML = self.config.prevArrow;
        self.nextMonthNav = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("span", "flatpickr-next-month");
        self.nextMonthNav.innerHTML = self.config.nextArrow;
        buildMonths();
        Object.defineProperty(self, "_hidePrevMonthArrow", {
            get: () => self.__hidePrevMonthArrow,
            set(bool) {
                if (self.__hidePrevMonthArrow !== bool) {
                    Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.prevMonthNav, "flatpickr-disabled", bool);
                    self.__hidePrevMonthArrow = bool;
                }
            },
        });
        Object.defineProperty(self, "_hideNextMonthArrow", {
            get: () => self.__hideNextMonthArrow,
            set(bool) {
                if (self.__hideNextMonthArrow !== bool) {
                    Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.nextMonthNav, "flatpickr-disabled", bool);
                    self.__hideNextMonthArrow = bool;
                }
            },
        });
        self.currentYearElement = self.yearElements[0];
        updateNavigationCurrentMonth();
        return self.monthNav;
    }
    function buildTime() {
        self.calendarContainer.classList.add("hasTime");
        if (self.config.noCalendar)
            self.calendarContainer.classList.add("noCalendar");
        const defaults = Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["getDefaultHours"])(self.config);
        self.timeContainer = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-time");
        self.timeContainer.tabIndex = -1;
        const separator = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("span", "flatpickr-time-separator", ":");
        const hourInput = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createNumberInput"])("flatpickr-hour", {
            "aria-label": self.l10n.hourAriaLabel,
        });
        self.hourElement = hourInput.getElementsByTagName("input")[0];
        const minuteInput = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createNumberInput"])("flatpickr-minute", {
            "aria-label": self.l10n.minuteAriaLabel,
        });
        self.minuteElement = minuteInput.getElementsByTagName("input")[0];
        self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
        self.hourElement.value = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["pad"])(self.latestSelectedDateObj
            ? self.latestSelectedDateObj.getHours()
            : self.config.time_24hr
                ? defaults.hours
                : military2ampm(defaults.hours));
        self.minuteElement.value = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["pad"])(self.latestSelectedDateObj
            ? self.latestSelectedDateObj.getMinutes()
            : defaults.minutes);
        self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
        self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
        self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
        self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
        self.hourElement.setAttribute("maxlength", "2");
        self.minuteElement.setAttribute("min", "0");
        self.minuteElement.setAttribute("max", "59");
        self.minuteElement.setAttribute("maxlength", "2");
        self.timeContainer.appendChild(hourInput);
        self.timeContainer.appendChild(separator);
        self.timeContainer.appendChild(minuteInput);
        if (self.config.time_24hr)
            self.timeContainer.classList.add("time24hr");
        if (self.config.enableSeconds) {
            self.timeContainer.classList.add("hasSeconds");
            const secondInput = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createNumberInput"])("flatpickr-second");
            self.secondElement = secondInput.getElementsByTagName("input")[0];
            self.secondElement.value = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["pad"])(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getSeconds()
                : defaults.seconds);
            self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
            self.secondElement.setAttribute("min", "0");
            self.secondElement.setAttribute("max", "59");
            self.secondElement.setAttribute("maxlength", "2");
            self.timeContainer.appendChild(Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("span", "flatpickr-time-separator", ":"));
            self.timeContainer.appendChild(secondInput);
        }
        if (!self.config.time_24hr) {
            self.amPM = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("span", "flatpickr-am-pm", self.l10n.amPM[Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])((self.latestSelectedDateObj
                ? self.hourElement.value
                : self.config.defaultHour) > 11)]);
            self.amPM.title = self.l10n.toggleTitle;
            self.amPM.tabIndex = -1;
            self.timeContainer.appendChild(self.amPM);
        }
        return self.timeContainer;
    }
    function buildWeekdays() {
        if (!self.weekdayContainer)
            self.weekdayContainer = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-weekdays");
        else
            Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["clearNode"])(self.weekdayContainer);
        for (let i = self.config.showMonths; i--;) {
            const container = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-weekdaycontainer");
            self.weekdayContainer.appendChild(container);
        }
        updateWeekdays();
        return self.weekdayContainer;
    }
    function updateWeekdays() {
        if (!self.weekdayContainer) {
            return;
        }
        const firstDayOfWeek = self.l10n.firstDayOfWeek;
        let weekdays = [...self.l10n.weekdays.shorthand];
        if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
            weekdays = [
                ...weekdays.splice(firstDayOfWeek, weekdays.length),
                ...weekdays.splice(0, firstDayOfWeek),
            ];
        }
        for (let i = self.config.showMonths; i--;) {
            self.weekdayContainer.children[i].innerHTML = `
      <span class='flatpickr-weekday'>
        ${weekdays.join("</span><span class='flatpickr-weekday'>")}
      </span>
      `;
        }
    }
    function buildWeeks() {
        self.calendarContainer.classList.add("hasWeeks");
        const weekWrapper = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-weekwrapper");
        weekWrapper.appendChild(Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
        const weekNumbers = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("div", "flatpickr-weeks");
        weekWrapper.appendChild(weekNumbers);
        return {
            weekWrapper,
            weekNumbers,
        };
    }
    function changeMonth(value, isOffset = true) {
        const delta = isOffset ? value : value - self.currentMonth;
        if ((delta < 0 && self._hidePrevMonthArrow === true) ||
            (delta > 0 && self._hideNextMonthArrow === true))
            return;
        self.currentMonth += delta;
        if (self.currentMonth < 0 || self.currentMonth > 11) {
            self.currentYear += self.currentMonth > 11 ? 1 : -1;
            self.currentMonth = (self.currentMonth + 12) % 12;
            triggerEvent("onYearChange");
            buildMonthSwitch();
        }
        buildDays();
        triggerEvent("onMonthChange");
        updateNavigationCurrentMonth();
    }
    function clear(triggerChangeEvent = true, toInitial = true) {
        self.input.value = "";
        if (self.altInput !== undefined)
            self.altInput.value = "";
        if (self.mobileInput !== undefined)
            self.mobileInput.value = "";
        self.selectedDates = [];
        self.latestSelectedDateObj = undefined;
        if (toInitial === true) {
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
        }
        if (self.config.enableTime === true) {
            const { hours, minutes, seconds } = Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["getDefaultHours"])(self.config);
            setHours(hours, minutes, seconds);
        }
        self.redraw();
        if (triggerChangeEvent)
            triggerEvent("onChange");
    }
    function close() {
        self.isOpen = false;
        if (!self.isMobile) {
            if (self.calendarContainer !== undefined) {
                self.calendarContainer.classList.remove("open");
            }
            if (self._input !== undefined) {
                self._input.classList.remove("active");
            }
        }
        triggerEvent("onClose");
    }
    function destroy() {
        if (self.config !== undefined)
            triggerEvent("onDestroy");
        for (let i = self._handlers.length; i--;) {
            self._handlers[i].remove();
        }
        self._handlers = [];
        if (self.mobileInput) {
            if (self.mobileInput.parentNode)
                self.mobileInput.parentNode.removeChild(self.mobileInput);
            self.mobileInput = undefined;
        }
        else if (self.calendarContainer && self.calendarContainer.parentNode) {
            if (self.config.static && self.calendarContainer.parentNode) {
                const wrapper = self.calendarContainer.parentNode;
                wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                if (wrapper.parentNode) {
                    while (wrapper.firstChild)
                        wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                    wrapper.parentNode.removeChild(wrapper);
                }
            }
            else
                self.calendarContainer.parentNode.removeChild(self.calendarContainer);
        }
        if (self.altInput) {
            self.input.type = "text";
            if (self.altInput.parentNode)
                self.altInput.parentNode.removeChild(self.altInput);
            delete self.altInput;
        }
        if (self.input) {
            self.input.type = self.input._type;
            self.input.classList.remove("flatpickr-input");
            self.input.removeAttribute("readonly");
        }
        [
            "_showTimeInput",
            "latestSelectedDateObj",
            "_hideNextMonthArrow",
            "_hidePrevMonthArrow",
            "__hideNextMonthArrow",
            "__hidePrevMonthArrow",
            "isMobile",
            "isOpen",
            "selectedDateElem",
            "minDateHasTime",
            "maxDateHasTime",
            "days",
            "daysContainer",
            "_input",
            "_positionElement",
            "innerContainer",
            "rContainer",
            "monthNav",
            "todayDateElem",
            "calendarContainer",
            "weekdayContainer",
            "prevMonthNav",
            "nextMonthNav",
            "monthsDropdownContainer",
            "currentMonthElement",
            "currentYearElement",
            "navigationCurrentMonth",
            "selectedDateElem",
            "config",
        ].forEach((k) => {
            try {
                delete self[k];
            }
            catch (_) { }
        });
    }
    function isCalendarElem(elem) {
        if (self.config.appendTo && self.config.appendTo.contains(elem))
            return true;
        return self.calendarContainer.contains(elem);
    }
    function documentClick(e) {
        if (self.isOpen && !self.config.inline) {
            const eventTarget = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e);
            const isCalendarElement = isCalendarElem(eventTarget);
            const isInput = eventTarget === self.input ||
                eventTarget === self.altInput ||
                self.element.contains(eventTarget) ||
                (e.path &&
                    e.path.indexOf &&
                    (~e.path.indexOf(self.input) ||
                        ~e.path.indexOf(self.altInput)));
            const lostFocus = e.type === "blur"
                ? isInput &&
                    e.relatedTarget &&
                    !isCalendarElem(e.relatedTarget)
                : !isInput &&
                    !isCalendarElement &&
                    !isCalendarElem(e.relatedTarget);
            const isIgnored = !self.config.ignoredFocusElements.some((elem) => elem.contains(eventTarget));
            if (lostFocus && isIgnored) {
                if (self.timeContainer !== undefined &&
                    self.minuteElement !== undefined &&
                    self.hourElement !== undefined &&
                    self.input.value !== "" &&
                    self.input.value !== undefined) {
                    updateTime();
                }
                self.close();
                if (self.config &&
                    self.config.mode === "range" &&
                    self.selectedDates.length === 1) {
                    self.clear(false);
                    self.redraw();
                }
            }
        }
    }
    function changeYear(newYear) {
        if (!newYear ||
            (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
            (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
            return;
        const newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
        self.currentYear = newYearNum || self.currentYear;
        if (self.config.maxDate &&
            self.currentYear === self.config.maxDate.getFullYear()) {
            self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
        }
        else if (self.config.minDate &&
            self.currentYear === self.config.minDate.getFullYear()) {
            self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
        }
        if (isNewYear) {
            self.redraw();
            triggerEvent("onYearChange");
            buildMonthSwitch();
        }
    }
    function isEnabled(date, timeless = true) {
        var _a;
        const dateToCheck = self.parseDate(date, undefined, timeless);
        if ((self.config.minDate &&
            dateToCheck &&
            Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
            (self.config.maxDate &&
                dateToCheck &&
                Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
            return false;
        if (!self.config.enable && self.config.disable.length === 0)
            return true;
        if (dateToCheck === undefined)
            return false;
        const bool = !!self.config.enable, array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
        for (let i = 0, d; i < array.length; i++) {
            d = array[i];
            if (typeof d === "function" &&
                d(dateToCheck))
                return bool;
            else if (d instanceof Date &&
                dateToCheck !== undefined &&
                d.getTime() === dateToCheck.getTime())
                return bool;
            else if (typeof d === "string") {
                const parsed = self.parseDate(d, undefined, true);
                return parsed && parsed.getTime() === dateToCheck.getTime()
                    ? bool
                    : !bool;
            }
            else if (typeof d === "object" &&
                dateToCheck !== undefined &&
                d.from &&
                d.to &&
                dateToCheck.getTime() >= d.from.getTime() &&
                dateToCheck.getTime() <= d.to.getTime())
                return bool;
        }
        return !bool;
    }
    function isInView(elem) {
        if (self.daysContainer !== undefined)
            return (elem.className.indexOf("hidden") === -1 &&
                elem.className.indexOf("flatpickr-disabled") === -1 &&
                self.daysContainer.contains(elem));
        return false;
    }
    function onBlur(e) {
        const isInput = e.target === self._input;
        if (isInput &&
            (self.selectedDates.length > 0 || self._input.value.length > 0) &&
            !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
            self.setDate(self._input.value, true, e.target === self.altInput
                ? self.config.altFormat
                : self.config.dateFormat);
        }
    }
    function onKeyDown(e) {
        const eventTarget = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e);
        const isInput = self.config.wrap
            ? element.contains(eventTarget)
            : eventTarget === self._input;
        const allowInput = self.config.allowInput;
        const allowKeydown = self.isOpen && (!allowInput || !isInput);
        const allowInlineKeydown = self.config.inline && isInput && !allowInput;
        if (e.keyCode === 13 && isInput) {
            if (allowInput) {
                self.setDate(self._input.value, true, eventTarget === self.altInput
                    ? self.config.altFormat
                    : self.config.dateFormat);
                return eventTarget.blur();
            }
            else {
                self.open();
            }
        }
        else if (isCalendarElem(eventTarget) ||
            allowKeydown ||
            allowInlineKeydown) {
            const isTimeObj = !!self.timeContainer &&
                self.timeContainer.contains(eventTarget);
            switch (e.keyCode) {
                case 13:
                    if (isTimeObj) {
                        e.preventDefault();
                        updateTime();
                        focusAndClose();
                    }
                    else
                        selectDate(e);
                    break;
                case 27:
                    e.preventDefault();
                    focusAndClose();
                    break;
                case 8:
                case 46:
                    if (isInput && !self.config.allowInput) {
                        e.preventDefault();
                        self.clear();
                    }
                    break;
                case 37:
                case 39:
                    if (!isTimeObj && !isInput) {
                        e.preventDefault();
                        if (self.daysContainer !== undefined &&
                            (allowInput === false ||
                                (document.activeElement && isInView(document.activeElement)))) {
                            const delta = e.keyCode === 39 ? 1 : -1;
                            if (!e.ctrlKey)
                                focusOnDay(undefined, delta);
                            else {
                                e.stopPropagation();
                                changeMonth(delta);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                        }
                    }
                    else if (self.hourElement)
                        self.hourElement.focus();
                    break;
                case 38:
                case 40:
                    e.preventDefault();
                    const delta = e.keyCode === 40 ? 1 : -1;
                    if ((self.daysContainer &&
                        eventTarget.$i !== undefined) ||
                        eventTarget === self.input ||
                        eventTarget === self.altInput) {
                        if (e.ctrlKey) {
                            e.stopPropagation();
                            changeYear(self.currentYear - delta);
                            focusOnDay(getFirstAvailableDay(1), 0);
                        }
                        else if (!isTimeObj)
                            focusOnDay(undefined, delta * 7);
                    }
                    else if (eventTarget === self.currentYearElement) {
                        changeYear(self.currentYear - delta);
                    }
                    else if (self.config.enableTime) {
                        if (!isTimeObj && self.hourElement)
                            self.hourElement.focus();
                        updateTime(e);
                        self._debouncedChange();
                    }
                    break;
                case 9:
                    if (isTimeObj) {
                        const elems = [
                            self.hourElement,
                            self.minuteElement,
                            self.secondElement,
                            self.amPM,
                        ]
                            .concat(self.pluginElements)
                            .filter((x) => x);
                        const i = elems.indexOf(eventTarget);
                        if (i !== -1) {
                            const target = elems[i + (e.shiftKey ? -1 : 1)];
                            e.preventDefault();
                            (target || self._input).focus();
                        }
                    }
                    else if (!self.config.noCalendar &&
                        self.daysContainer &&
                        self.daysContainer.contains(eventTarget) &&
                        e.shiftKey) {
                        e.preventDefault();
                        self._input.focus();
                    }
                    break;
                default:
                    break;
            }
        }
        if (self.amPM !== undefined && eventTarget === self.amPM) {
            switch (e.key) {
                case self.l10n.amPM[0].charAt(0):
                case self.l10n.amPM[0].charAt(0).toLowerCase():
                    self.amPM.textContent = self.l10n.amPM[0];
                    setHoursFromInputs();
                    updateValue();
                    break;
                case self.l10n.amPM[1].charAt(0):
                case self.l10n.amPM[1].charAt(0).toLowerCase():
                    self.amPM.textContent = self.l10n.amPM[1];
                    setHoursFromInputs();
                    updateValue();
                    break;
            }
        }
        if (isInput || isCalendarElem(eventTarget)) {
            triggerEvent("onKeyDown", e);
        }
    }
    function onMouseOver(elem) {
        if (self.selectedDates.length !== 1 ||
            (elem &&
                (!elem.classList.contains("flatpickr-day") ||
                    elem.classList.contains("flatpickr-disabled"))))
            return;
        const hoverDate = elem
            ? elem.dateObj.getTime()
            : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
        let containsDisabled = false;
        let minRange = 0, maxRange = 0;
        for (let t = rangeStartDate; t < rangeEndDate; t += _utils_dates__WEBPACK_IMPORTED_MODULE_4__["duration"].DAY) {
            if (!isEnabled(new Date(t), true)) {
                containsDisabled =
                    containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                if (t < initialDate && (!minRange || t > minRange))
                    minRange = t;
                else if (t > initialDate && (!maxRange || t < maxRange))
                    maxRange = t;
            }
        }
        for (let m = 0; m < self.config.showMonths; m++) {
            const month = self.daysContainer.children[m];
            for (let i = 0, l = month.children.length; i < l; i++) {
                const dayElem = month.children[i], date = dayElem.dateObj;
                const timestamp = date.getTime();
                const outOfRange = (minRange > 0 && timestamp < minRange) ||
                    (maxRange > 0 && timestamp > maxRange);
                if (outOfRange) {
                    dayElem.classList.add("notAllowed");
                    ["inRange", "startRange", "endRange"].forEach((c) => {
                        dayElem.classList.remove(c);
                    });
                    continue;
                }
                else if (containsDisabled && !outOfRange)
                    continue;
                ["startRange", "inRange", "endRange", "notAllowed"].forEach((c) => {
                    dayElem.classList.remove(c);
                });
                if (elem !== undefined) {
                    elem.classList.add(hoverDate <= self.selectedDates[0].getTime()
                        ? "startRange"
                        : "endRange");
                    if (initialDate < hoverDate && timestamp === initialDate)
                        dayElem.classList.add("startRange");
                    else if (initialDate > hoverDate && timestamp === initialDate)
                        dayElem.classList.add("endRange");
                    if (timestamp >= minRange &&
                        (maxRange === 0 || timestamp <= maxRange) &&
                        Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["isBetween"])(timestamp, initialDate, hoverDate))
                        dayElem.classList.add("inRange");
                }
            }
        }
    }
    function onResize() {
        if (self.isOpen && !self.config.static && !self.config.inline)
            positionCalendar();
    }
    function open(e, positionElement = self._positionElement) {
        if (self.isMobile === true) {
            if (e) {
                e.preventDefault();
                const eventTarget = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e);
                if (eventTarget) {
                    eventTarget.blur();
                }
            }
            if (self.mobileInput !== undefined) {
                self.mobileInput.focus();
                self.mobileInput.click();
            }
            triggerEvent("onOpen");
            return;
        }
        else if (self._input.disabled || self.config.inline) {
            return;
        }
        const wasOpen = self.isOpen;
        self.isOpen = true;
        if (!wasOpen) {
            self.calendarContainer.classList.add("open");
            self._input.classList.add("active");
            triggerEvent("onOpen");
            positionCalendar(positionElement);
        }
        if (self.config.enableTime === true && self.config.noCalendar === true) {
            if (self.config.allowInput === false &&
                (e === undefined ||
                    !self.timeContainer.contains(e.relatedTarget))) {
                setTimeout(() => self.hourElement.select(), 50);
            }
        }
    }
    function minMaxDateSetter(type) {
        return (date) => {
            const dateObj = (self.config[`_${type}Date`] = self.parseDate(date, self.config.dateFormat));
            const inverseDateObj = self.config[`_${type === "min" ? "max" : "min"}Date`];
            if (dateObj !== undefined) {
                self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                    dateObj.getHours() > 0 ||
                        dateObj.getMinutes() > 0 ||
                        dateObj.getSeconds() > 0;
            }
            if (self.selectedDates) {
                self.selectedDates = self.selectedDates.filter((d) => isEnabled(d));
                if (!self.selectedDates.length && type === "min")
                    setHoursFromDate(dateObj);
                updateValue();
            }
            if (self.daysContainer) {
                redraw();
                if (dateObj !== undefined)
                    self.currentYearElement[type] = dateObj.getFullYear().toString();
                else
                    self.currentYearElement.removeAttribute(type);
                self.currentYearElement.disabled =
                    !!inverseDateObj &&
                        dateObj !== undefined &&
                        inverseDateObj.getFullYear() === dateObj.getFullYear();
            }
        };
    }
    function parseConfig() {
        const boolOpts = [
            "wrap",
            "weekNumbers",
            "allowInput",
            "allowInvalidPreload",
            "clickOpens",
            "time_24hr",
            "enableTime",
            "noCalendar",
            "altInput",
            "shorthandCurrentMonth",
            "inline",
            "static",
            "enableSeconds",
            "disableMobile",
        ];
        const userConfig = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
        const formats = {};
        self.config.parseDate = userConfig.parseDate;
        self.config.formatDate = userConfig.formatDate;
        Object.defineProperty(self.config, "enable", {
            get: () => self.config._enable,
            set: (dates) => {
                self.config._enable = parseDateRules(dates);
            },
        });
        Object.defineProperty(self.config, "disable", {
            get: () => self.config._disable,
            set: (dates) => {
                self.config._disable = parseDateRules(dates);
            },
        });
        const timeMode = userConfig.mode === "time";
        if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
            const defaultDateFormat = flatpickr.defaultConfig.dateFormat || _types_options__WEBPACK_IMPORTED_MODULE_0__["defaults"].dateFormat;
            formats.dateFormat =
                userConfig.noCalendar || timeMode
                    ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                    : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
        }
        if (userConfig.altInput &&
            (userConfig.enableTime || timeMode) &&
            !userConfig.altFormat) {
            const defaultAltFormat = flatpickr.defaultConfig.altFormat || _types_options__WEBPACK_IMPORTED_MODULE_0__["defaults"].altFormat;
            formats.altFormat =
                userConfig.noCalendar || timeMode
                    ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                    : defaultAltFormat + ` h:i${userConfig.enableSeconds ? ":S" : ""} K`;
        }
        Object.defineProperty(self.config, "minDate", {
            get: () => self.config._minDate,
            set: minMaxDateSetter("min"),
        });
        Object.defineProperty(self.config, "maxDate", {
            get: () => self.config._maxDate,
            set: minMaxDateSetter("max"),
        });
        const minMaxTimeSetter = (type) => (val) => {
            self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
        };
        Object.defineProperty(self.config, "minTime", {
            get: () => self.config._minTime,
            set: minMaxTimeSetter("min"),
        });
        Object.defineProperty(self.config, "maxTime", {
            get: () => self.config._maxTime,
            set: minMaxTimeSetter("max"),
        });
        if (userConfig.mode === "time") {
            self.config.noCalendar = true;
            self.config.enableTime = true;
        }
        Object.assign(self.config, formats, userConfig);
        for (let i = 0; i < boolOpts.length; i++)
            self.config[boolOpts[i]] =
                self.config[boolOpts[i]] === true ||
                    self.config[boolOpts[i]] === "true";
        _types_options__WEBPACK_IMPORTED_MODULE_0__["HOOKS"].filter((hook) => self.config[hook] !== undefined).forEach((hook) => {
            self.config[hook] = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(self.config[hook] || []).map(bindToInstance);
        });
        self.isMobile =
            !self.config.disableMobile &&
                !self.config.inline &&
                self.config.mode === "single" &&
                !self.config.disable.length &&
                !self.config.enable &&
                !self.config.weekNumbers &&
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        for (let i = 0; i < self.config.plugins.length; i++) {
            const pluginConf = self.config.plugins[i](self) || {};
            for (const key in pluginConf) {
                if (_types_options__WEBPACK_IMPORTED_MODULE_0__["HOOKS"].indexOf(key) > -1) {
                    self.config[key] = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(pluginConf[key])
                        .map(bindToInstance)
                        .concat(self.config[key]);
                }
                else if (typeof userConfig[key] === "undefined")
                    self.config[key] = pluginConf[key];
            }
        }
        if (!userConfig.altInputClass) {
            self.config.altInputClass =
                getInputElem().className + " " + self.config.altInputClass;
        }
        triggerEvent("onParseConfig");
    }
    function getInputElem() {
        return self.config.wrap
            ? element.querySelector("[data-input]")
            : element;
    }
    function setupLocale() {
        if (typeof self.config.locale !== "object" &&
            typeof flatpickr.l10ns[self.config.locale] === "undefined")
            self.config.errorHandler(new Error(`flatpickr: invalid locale ${self.config.locale}`));
        self.l10n = Object.assign(Object.assign({}, flatpickr.l10ns.default), (typeof self.config.locale === "object"
            ? self.config.locale
            : self.config.locale !== "default"
                ? flatpickr.l10ns[self.config.locale]
                : undefined));
        _utils_formatting__WEBPACK_IMPORTED_MODULE_5__["tokenRegex"].K = `(${self.l10n.amPM[0]}|${self.l10n.amPM[1]}|${self.l10n.amPM[0].toLowerCase()}|${self.l10n.amPM[1].toLowerCase()})`;
        const userConfig = Object.assign(Object.assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
        if (userConfig.time_24hr === undefined &&
            flatpickr.defaultConfig.time_24hr === undefined) {
            self.config.time_24hr = self.l10n.time_24hr;
        }
        self.formatDate = Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["createDateFormatter"])(self);
        self.parseDate = Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["createDateParser"])({ config: self.config, l10n: self.l10n });
    }
    function positionCalendar(customPositionElement) {
        if (typeof self.config.position === "function") {
            return void self.config.position(self, customPositionElement);
        }
        if (self.calendarContainer === undefined)
            return;
        triggerEvent("onPreCalendarPosition");
        const positionElement = customPositionElement || self._positionElement;
        const calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, ((acc, child) => acc + child.offsetHeight), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
            (configPosVertical !== "below" &&
                distanceFromBottom < calendarHeight &&
                inputBounds.top > calendarHeight);
        const top = window.pageYOffset +
            inputBounds.top +
            (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "arrowTop", !showOnTop);
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "arrowBottom", showOnTop);
        if (self.config.inline)
            return;
        let left = window.pageXOffset + inputBounds.left;
        let isCenter = false;
        let isRight = false;
        if (configPosHorizontal === "center") {
            left -= (calendarWidth - inputBounds.width) / 2;
            isCenter = true;
        }
        else if (configPosHorizontal === "right") {
            left -= calendarWidth - inputBounds.width;
            isRight = true;
        }
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "arrowCenter", isCenter);
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "arrowRight", isRight);
        const right = window.document.body.offsetWidth -
            (window.pageXOffset + inputBounds.right);
        const rightMost = left + calendarWidth > window.document.body.offsetWidth;
        const centerMost = right + calendarWidth > window.document.body.offsetWidth;
        Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "rightMost", rightMost);
        if (self.config.static)
            return;
        self.calendarContainer.style.top = `${top}px`;
        if (!rightMost) {
            self.calendarContainer.style.left = `${left}px`;
            self.calendarContainer.style.right = "auto";
        }
        else if (!centerMost) {
            self.calendarContainer.style.left = "auto";
            self.calendarContainer.style.right = `${right}px`;
        }
        else {
            const doc = getDocumentStyleSheet();
            if (doc === undefined)
                return;
            const bodyWidth = window.document.body.offsetWidth;
            const centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
            const centerBefore = ".flatpickr-calendar.centerMost:before";
            const centerAfter = ".flatpickr-calendar.centerMost:after";
            const centerIndex = doc.cssRules.length;
            const centerStyle = `{left:${inputBounds.left}px;right:auto;}`;
            Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "rightMost", false);
            Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["toggleClass"])(self.calendarContainer, "centerMost", true);
            doc.insertRule(`${centerBefore},${centerAfter}${centerStyle}`, centerIndex);
            self.calendarContainer.style.left = `${centerLeft}px`;
            self.calendarContainer.style.right = "auto";
        }
    }
    function getDocumentStyleSheet() {
        let editableSheet = null;
        for (let i = 0; i < document.styleSheets.length; i++) {
            const sheet = document.styleSheets[i];
            try {
                sheet.cssRules;
            }
            catch (err) {
                continue;
            }
            editableSheet = sheet;
            break;
        }
        return editableSheet != null ? editableSheet : createStyleSheet();
    }
    function createStyleSheet() {
        const style = document.createElement("style");
        document.head.appendChild(style);
        return style.sheet;
    }
    function redraw() {
        if (self.config.noCalendar || self.isMobile)
            return;
        buildMonthSwitch();
        updateNavigationCurrentMonth();
        buildDays();
    }
    function focusAndClose() {
        self._input.focus();
        if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
            navigator.msMaxTouchPoints !== undefined) {
            setTimeout(self.close, 0);
        }
        else {
            self.close();
        }
    }
    function selectDate(e) {
        e.preventDefault();
        e.stopPropagation();
        const isSelectable = (day) => day.classList &&
            day.classList.contains("flatpickr-day") &&
            !day.classList.contains("flatpickr-disabled") &&
            !day.classList.contains("notAllowed");
        const t = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["findParent"])(Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e), isSelectable);
        if (t === undefined)
            return;
        const target = t;
        const selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
        const shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
            selectedDate.getMonth() >
                self.currentMonth + self.config.showMonths - 1) &&
            self.config.mode !== "range";
        self.selectedDateElem = target;
        if (self.config.mode === "single")
            self.selectedDates = [selectedDate];
        else if (self.config.mode === "multiple") {
            const selectedIndex = isDateSelected(selectedDate);
            if (selectedIndex)
                self.selectedDates.splice(parseInt(selectedIndex), 1);
            else
                self.selectedDates.push(selectedDate);
        }
        else if (self.config.mode === "range") {
            if (self.selectedDates.length === 2) {
                self.clear(false, false);
            }
            self.latestSelectedDateObj = selectedDate;
            self.selectedDates.push(selectedDate);
            if (Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(selectedDate, self.selectedDates[0], true) !== 0)
                self.selectedDates.sort((a, b) => a.getTime() - b.getTime());
        }
        setHoursFromInputs();
        if (shouldChangeMonth) {
            const isNewYear = self.currentYear !== selectedDate.getFullYear();
            self.currentYear = selectedDate.getFullYear();
            self.currentMonth = selectedDate.getMonth();
            if (isNewYear) {
                triggerEvent("onYearChange");
                buildMonthSwitch();
            }
            triggerEvent("onMonthChange");
        }
        updateNavigationCurrentMonth();
        buildDays();
        updateValue();
        if (!shouldChangeMonth &&
            self.config.mode !== "range" &&
            self.config.showMonths === 1)
            focusOnDayElem(target);
        else if (self.selectedDateElem !== undefined &&
            self.hourElement === undefined) {
            self.selectedDateElem && self.selectedDateElem.focus();
        }
        if (self.hourElement !== undefined)
            self.hourElement !== undefined && self.hourElement.focus();
        if (self.config.closeOnSelect) {
            const single = self.config.mode === "single" && !self.config.enableTime;
            const range = self.config.mode === "range" &&
                self.selectedDates.length === 2 &&
                !self.config.enableTime;
            if (single || range) {
                focusAndClose();
            }
        }
        triggerChange();
    }
    const CALLBACKS = {
        locale: [setupLocale, updateWeekdays],
        showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
        minDate: [jumpToDate],
        maxDate: [jumpToDate],
        clickOpens: [
            () => {
                if (self.config.clickOpens === true) {
                    bind(self._input, "focus", self.open);
                    bind(self._input, "click", self.open);
                }
                else {
                    self._input.removeEventListener("focus", self.open);
                    self._input.removeEventListener("click", self.open);
                }
            },
        ],
    };
    function set(option, value) {
        if (option !== null && typeof option === "object") {
            Object.assign(self.config, option);
            for (const key in option) {
                if (CALLBACKS[key] !== undefined)
                    CALLBACKS[key].forEach((x) => x());
            }
        }
        else {
            self.config[option] = value;
            if (CALLBACKS[option] !== undefined)
                CALLBACKS[option].forEach((x) => x());
            else if (_types_options__WEBPACK_IMPORTED_MODULE_0__["HOOKS"].indexOf(option) > -1)
                self.config[option] = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(value);
        }
        self.redraw();
        updateValue(true);
    }
    function setSelectedDate(inputDate, format) {
        let dates = [];
        if (inputDate instanceof Array)
            dates = inputDate.map((d) => self.parseDate(d, format));
        else if (inputDate instanceof Date || typeof inputDate === "number")
            dates = [self.parseDate(inputDate, format)];
        else if (typeof inputDate === "string") {
            switch (self.config.mode) {
                case "single":
                case "time":
                    dates = [self.parseDate(inputDate, format)];
                    break;
                case "multiple":
                    dates = inputDate
                        .split(self.config.conjunction)
                        .map((date) => self.parseDate(date, format));
                    break;
                case "range":
                    dates = inputDate
                        .split(self.l10n.rangeSeparator)
                        .map((date) => self.parseDate(date, format));
                    break;
                default:
                    break;
            }
        }
        else
            self.config.errorHandler(new Error(`Invalid date supplied: ${JSON.stringify(inputDate)}`));
        self.selectedDates = (self.config.allowInvalidPreload
            ? dates
            : dates.filter((d) => d instanceof Date && isEnabled(d, false)));
        if (self.config.mode === "range")
            self.selectedDates.sort((a, b) => a.getTime() - b.getTime());
    }
    function setDate(date, triggerChange = false, format = self.config.dateFormat) {
        if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
            return self.clear(triggerChange);
        setSelectedDate(date, format);
        self.latestSelectedDateObj =
            self.selectedDates[self.selectedDates.length - 1];
        self.redraw();
        jumpToDate(undefined, triggerChange);
        setHoursFromDate();
        if (self.selectedDates.length === 0) {
            self.clear(false);
        }
        updateValue(triggerChange);
        if (triggerChange)
            triggerEvent("onChange");
    }
    function parseDateRules(arr) {
        return arr
            .slice()
            .map((rule) => {
            if (typeof rule === "string" ||
                typeof rule === "number" ||
                rule instanceof Date) {
                return self.parseDate(rule, undefined, true);
            }
            else if (rule &&
                typeof rule === "object" &&
                rule.from &&
                rule.to)
                return {
                    from: self.parseDate(rule.from, undefined),
                    to: self.parseDate(rule.to, undefined),
                };
            return rule;
        })
            .filter((x) => x);
    }
    function setupDates() {
        self.selectedDates = [];
        self.now = self.parseDate(self.config.now) || new Date();
        const preloadedDate = self.config.defaultDate ||
            ((self.input.nodeName === "INPUT" ||
                self.input.nodeName === "TEXTAREA") &&
                self.input.placeholder &&
                self.input.value === self.input.placeholder
                ? null
                : self.input.value);
        if (preloadedDate)
            setSelectedDate(preloadedDate, self.config.dateFormat);
        self._initialDate =
            self.selectedDates.length > 0
                ? self.selectedDates[0]
                : self.config.minDate &&
                    self.config.minDate.getTime() > self.now.getTime()
                    ? self.config.minDate
                    : self.config.maxDate &&
                        self.config.maxDate.getTime() < self.now.getTime()
                        ? self.config.maxDate
                        : self.now;
        self.currentYear = self._initialDate.getFullYear();
        self.currentMonth = self._initialDate.getMonth();
        if (self.selectedDates.length > 0)
            self.latestSelectedDateObj = self.selectedDates[0];
        if (self.config.minTime !== undefined)
            self.config.minTime = self.parseDate(self.config.minTime, "H:i");
        if (self.config.maxTime !== undefined)
            self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
        self.minDateHasTime =
            !!self.config.minDate &&
                (self.config.minDate.getHours() > 0 ||
                    self.config.minDate.getMinutes() > 0 ||
                    self.config.minDate.getSeconds() > 0);
        self.maxDateHasTime =
            !!self.config.maxDate &&
                (self.config.maxDate.getHours() > 0 ||
                    self.config.maxDate.getMinutes() > 0 ||
                    self.config.maxDate.getSeconds() > 0);
    }
    function setupInputs() {
        self.input = getInputElem();
        if (!self.input) {
            self.config.errorHandler(new Error("Invalid input element specified"));
            return;
        }
        self.input._type = self.input.type;
        self.input.type = "text";
        self.input.classList.add("flatpickr-input");
        self._input = self.input;
        if (self.config.altInput) {
            self.altInput = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])(self.input.nodeName, self.config.altInputClass);
            self._input = self.altInput;
            self.altInput.placeholder = self.input.placeholder;
            self.altInput.disabled = self.input.disabled;
            self.altInput.required = self.input.required;
            self.altInput.tabIndex = self.input.tabIndex;
            self.altInput.type = "text";
            self.input.setAttribute("type", "hidden");
            if (!self.config.static && self.input.parentNode)
                self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
        }
        if (!self.config.allowInput)
            self._input.setAttribute("readonly", "readonly");
        self._positionElement = self.config.positionElement || self._input;
    }
    function setupMobile() {
        const inputType = self.config.enableTime
            ? self.config.noCalendar
                ? "time"
                : "datetime-local"
            : "date";
        self.mobileInput = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["createElement"])("input", self.input.className + " flatpickr-mobile");
        self.mobileInput.tabIndex = 1;
        self.mobileInput.type = inputType;
        self.mobileInput.disabled = self.input.disabled;
        self.mobileInput.required = self.input.required;
        self.mobileInput.placeholder = self.input.placeholder;
        self.mobileFormatStr =
            inputType === "datetime-local"
                ? "Y-m-d\\TH:i:S"
                : inputType === "date"
                    ? "Y-m-d"
                    : "H:i:S";
        if (self.selectedDates.length > 0) {
            self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
        }
        if (self.config.minDate)
            self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
        if (self.config.maxDate)
            self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
        if (self.input.getAttribute("step"))
            self.mobileInput.step = String(self.input.getAttribute("step"));
        self.input.type = "hidden";
        if (self.altInput !== undefined)
            self.altInput.type = "hidden";
        try {
            if (self.input.parentNode)
                self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
        }
        catch (_a) { }
        bind(self.mobileInput, "change", (e) => {
            self.setDate(Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e).value, false, self.mobileFormatStr);
            triggerEvent("onChange");
            triggerEvent("onClose");
        });
    }
    function toggle(e) {
        if (self.isOpen === true)
            return self.close();
        self.open(e);
    }
    function triggerEvent(event, data) {
        if (self.config === undefined)
            return;
        const hooks = self.config[event];
        if (hooks !== undefined && hooks.length > 0) {
            for (let i = 0; hooks[i] && i < hooks.length; i++)
                hooks[i](self.selectedDates, self.input.value, self, data);
        }
        if (event === "onChange") {
            self.input.dispatchEvent(createEvent("change"));
            self.input.dispatchEvent(createEvent("input"));
        }
    }
    function createEvent(name) {
        const e = document.createEvent("Event");
        e.initEvent(name, true, true);
        return e;
    }
    function isDateSelected(date) {
        for (let i = 0; i < self.selectedDates.length; i++) {
            if (Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(self.selectedDates[i], date) === 0)
                return "" + i;
        }
        return false;
    }
    function isDateInRange(date) {
        if (self.config.mode !== "range" || self.selectedDates.length < 2)
            return false;
        return (Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(date, self.selectedDates[0]) >= 0 &&
            Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"])(date, self.selectedDates[1]) <= 0);
    }
    function updateNavigationCurrentMonth() {
        if (self.config.noCalendar || self.isMobile || !self.monthNav)
            return;
        self.yearElements.forEach((yearElement, i) => {
            const d = new Date(self.currentYear, self.currentMonth, 1);
            d.setMonth(self.currentMonth + i);
            if (self.config.showMonths > 1 ||
                self.config.monthSelectorType === "static") {
                self.monthElements[i].textContent =
                    Object(_utils_formatting__WEBPACK_IMPORTED_MODULE_5__["monthToStr"])(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
            }
            else {
                self.monthsDropdownContainer.value = d.getMonth().toString();
            }
            yearElement.value = d.getFullYear().toString();
        });
        self._hidePrevMonthArrow =
            self.config.minDate !== undefined &&
                (self.currentYear === self.config.minDate.getFullYear()
                    ? self.currentMonth <= self.config.minDate.getMonth()
                    : self.currentYear < self.config.minDate.getFullYear());
        self._hideNextMonthArrow =
            self.config.maxDate !== undefined &&
                (self.currentYear === self.config.maxDate.getFullYear()
                    ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                    : self.currentYear > self.config.maxDate.getFullYear());
    }
    function getDateStr(format) {
        return self.selectedDates
            .map((dObj) => self.formatDate(dObj, format))
            .filter((d, i, arr) => self.config.mode !== "range" ||
            self.config.enableTime ||
            arr.indexOf(d) === i)
            .join(self.config.mode !== "range"
            ? self.config.conjunction
            : self.l10n.rangeSeparator);
    }
    function updateValue(triggerChange = true) {
        if (self.mobileInput !== undefined && self.mobileFormatStr) {
            self.mobileInput.value =
                self.latestSelectedDateObj !== undefined
                    ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                    : "";
        }
        self.input.value = getDateStr(self.config.dateFormat);
        if (self.altInput !== undefined) {
            self.altInput.value = getDateStr(self.config.altFormat);
        }
        if (triggerChange !== false)
            triggerEvent("onValueUpdate");
    }
    function onMonthNavClick(e) {
        const eventTarget = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e);
        const isPrevMonth = self.prevMonthNav.contains(eventTarget);
        const isNextMonth = self.nextMonthNav.contains(eventTarget);
        if (isPrevMonth || isNextMonth) {
            changeMonth(isPrevMonth ? -1 : 1);
        }
        else if (self.yearElements.indexOf(eventTarget) >= 0) {
            eventTarget.select();
        }
        else if (eventTarget.classList.contains("arrowUp")) {
            self.changeYear(self.currentYear + 1);
        }
        else if (eventTarget.classList.contains("arrowDown")) {
            self.changeYear(self.currentYear - 1);
        }
    }
    function timeWrapper(e) {
        e.preventDefault();
        const isKeyDown = e.type === "keydown", eventTarget = Object(_utils_dom__WEBPACK_IMPORTED_MODULE_3__["getEventTarget"])(e), input = eventTarget;
        if (self.amPM !== undefined && eventTarget === self.amPM) {
            self.amPM.textContent =
                self.l10n.amPM[Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])(self.amPM.textContent === self.l10n.amPM[0])];
        }
        const min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
            (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
        let newValue = curValue + step * delta;
        if (typeof input.value !== "undefined" && input.value.length === 2) {
            const isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
            if (newValue < min) {
                newValue =
                    max +
                        newValue +
                        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])(!isHourElem) +
                        (Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])(isHourElem) && Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])(!self.amPM));
                if (isMinuteElem)
                    incrementNumInput(undefined, -1, self.hourElement);
            }
            else if (newValue > max) {
                newValue =
                    input === self.hourElement ? newValue - max - Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])(!self.amPM) : min;
                if (isMinuteElem)
                    incrementNumInput(undefined, 1, self.hourElement);
            }
            if (self.amPM &&
                isHourElem &&
                (step === 1
                    ? newValue + curValue === 23
                    : Math.abs(newValue - curValue) > step)) {
                self.amPM.textContent =
                    self.l10n.amPM[Object(_utils__WEBPACK_IMPORTED_MODULE_2__["int"])(self.amPM.textContent === self.l10n.amPM[0])];
            }
            input.value = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["pad"])(newValue);
        }
    }
    init();
    return self;
}
function _flatpickr(nodeList, config) {
    const nodes = Array.prototype.slice
        .call(nodeList)
        .filter((x) => x instanceof HTMLElement);
    const instances = [];
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        try {
            if (node.getAttribute("data-fp-omit") !== null)
                continue;
            if (node._flatpickr !== undefined) {
                node._flatpickr.destroy();
                node._flatpickr = undefined;
            }
            node._flatpickr = FlatpickrInstance(node, config || {});
            instances.push(node._flatpickr);
        }
        catch (e) {
            console.error(e);
        }
    }
    return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" &&
    typeof HTMLCollection !== "undefined" &&
    typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
        return _flatpickr(this, config);
    };
    HTMLElement.prototype.flatpickr = function (config) {
        return _flatpickr([this], config);
    };
}
var flatpickr = function (selector, config) {
    if (typeof selector === "string") {
        return _flatpickr(window.document.querySelectorAll(selector), config);
    }
    else if (selector instanceof Node) {
        return _flatpickr([selector], config);
    }
    else {
        return _flatpickr(selector, config);
    }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
    en: Object.assign({}, _l10n_default__WEBPACK_IMPORTED_MODULE_1__["default"]),
    default: Object.assign({}, _l10n_default__WEBPACK_IMPORTED_MODULE_1__["default"]),
};
flatpickr.localize = (l10n) => {
    flatpickr.l10ns.default = Object.assign(Object.assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = (config) => {
    flatpickr.defaultConfig = Object.assign(Object.assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["createDateParser"])({});
flatpickr.formatDate = Object(_utils_dates__WEBPACK_IMPORTED_MODULE_4__["createDateFormatter"])({});
flatpickr.compareDates = _utils_dates__WEBPACK_IMPORTED_MODULE_4__["compareDates"];
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function (config) {
        return _flatpickr(this, config);
    };
}
Date.prototype.fp_incr = function (days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
}
/* harmony default export */ __webpack_exports__["default"] = (flatpickr);


/***/ }),

/***/ "./node_modules/flatpickr/dist/esm/l10n/default.js":
/*!*********************************************************!*\
  !*** ./node_modules/flatpickr/dist/esm/l10n/default.js ***!
  \*********************************************************/
/*! exports provided: english, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "english", function() { return english; });
const english = {
    weekdays: {
        shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        longhand: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
        ],
    },
    months: {
        shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec",
        ],
        longhand: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ],
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: (nth) => {
        const s = nth % 100;
        if (s > 3 && s < 21)
            return "th";
        switch (s % 10) {
            case 1:
                return "st";
            case 2:
                return "nd";
            case 3:
                return "rd";
            default:
                return "th";
        }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false,
};
/* harmony default export */ __webpack_exports__["default"] = (english);


/***/ }),

/***/ "./node_modules/flatpickr/dist/esm/types/options.js":
/*!**********************************************************!*\
  !*** ./node_modules/flatpickr/dist/esm/types/options.js ***!
  \**********************************************************/
/*! exports provided: HOOKS, defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOOKS", function() { return HOOKS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return defaults; });
const HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition",
];
const defaults = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" &&
        window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: (err) => typeof console !== "undefined" && console.warn(err),
    getWeek: (givenDate) => {
        const date = new Date(givenDate.getTime());
        date.setHours(0, 0, 0, 0);
        date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
        var week1 = new Date(date.getFullYear(), 0, 4);
        return (1 +
            Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                3 +
                ((week1.getDay() + 6) % 7)) /
                7));
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: undefined,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false,
};


/***/ }),

/***/ "./node_modules/flatpickr/dist/esm/utils/dates.js":
/*!********************************************************!*\
  !*** ./node_modules/flatpickr/dist/esm/utils/dates.js ***!
  \********************************************************/
/*! exports provided: createDateFormatter, createDateParser, compareDates, compareTimes, isBetween, duration, getDefaultHours */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDateFormatter", function() { return createDateFormatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDateParser", function() { return createDateParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareDates", function() { return compareDates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareTimes", function() { return compareTimes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBetween", function() { return isBetween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "duration", function() { return duration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultHours", function() { return getDefaultHours; });
/* harmony import */ var _formatting__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatting */ "./node_modules/flatpickr/dist/esm/utils/formatting.js");
/* harmony import */ var _types_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/options */ "./node_modules/flatpickr/dist/esm/types/options.js");
/* harmony import */ var _l10n_default__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../l10n/default */ "./node_modules/flatpickr/dist/esm/l10n/default.js");



const createDateFormatter = ({ config = _types_options__WEBPACK_IMPORTED_MODULE_1__["defaults"], l10n = _l10n_default__WEBPACK_IMPORTED_MODULE_2__["english"], isMobile = false, }) => (dateObj, frmt, overrideLocale) => {
    const locale = overrideLocale || l10n;
    if (config.formatDate !== undefined && !isMobile) {
        return config.formatDate(dateObj, frmt, locale);
    }
    return frmt
        .split("")
        .map((c, i, arr) => _formatting__WEBPACK_IMPORTED_MODULE_0__["formats"][c] && arr[i - 1] !== "\\"
        ? _formatting__WEBPACK_IMPORTED_MODULE_0__["formats"][c](dateObj, locale, config)
        : c !== "\\"
            ? c
            : "")
        .join("");
};
const createDateParser = ({ config = _types_options__WEBPACK_IMPORTED_MODULE_1__["defaults"], l10n = _l10n_default__WEBPACK_IMPORTED_MODULE_2__["english"] }) => (date, givenFormat, timeless, customLocale) => {
    if (date !== 0 && !date)
        return undefined;
    const locale = customLocale || l10n;
    let parsedDate;
    const dateOrig = date;
    if (date instanceof Date)
        parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" &&
        date.toFixed !== undefined)
        parsedDate = new Date(date);
    else if (typeof date === "string") {
        const format = givenFormat || (config || _types_options__WEBPACK_IMPORTED_MODULE_1__["defaults"]).dateFormat;
        const datestr = String(date).trim();
        if (datestr === "today") {
            parsedDate = new Date();
            timeless = true;
        }
        else if (/Z$/.test(datestr) ||
            /GMT$/.test(datestr))
            parsedDate = new Date(date);
        else if (config && config.parseDate)
            parsedDate = config.parseDate(date, format);
        else {
            parsedDate =
                !config || !config.noCalendar
                    ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                    : new Date(new Date().setHours(0, 0, 0, 0));
            let matched, ops = [];
            for (let i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                const token = format[i];
                const isBackSlash = token === "\\";
                const escaped = format[i - 1] === "\\" || isBackSlash;
                if (_formatting__WEBPACK_IMPORTED_MODULE_0__["tokenRegex"][token] && !escaped) {
                    regexStr += _formatting__WEBPACK_IMPORTED_MODULE_0__["tokenRegex"][token];
                    const match = new RegExp(regexStr).exec(date);
                    if (match && (matched = true)) {
                        ops[token !== "Y" ? "push" : "unshift"]({
                            fn: _formatting__WEBPACK_IMPORTED_MODULE_0__["revFormat"][token],
                            val: match[++matchIndex],
                        });
                    }
                }
                else if (!isBackSlash)
                    regexStr += ".";
                ops.forEach(({ fn, val }) => (parsedDate = fn(parsedDate, val, locale) || parsedDate));
            }
            parsedDate = matched ? parsedDate : undefined;
        }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
        config.errorHandler(new Error(`Invalid date provided: ${dateOrig}`));
        return undefined;
    }
    if (timeless === true)
        parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
};
function compareDates(date1, date2, timeless = true) {
    if (timeless !== false) {
        return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
            new Date(date2.getTime()).setHours(0, 0, 0, 0));
    }
    return date1.getTime() - date2.getTime();
}
function compareTimes(date1, date2) {
    return (3600 * (date1.getHours() - date2.getHours()) +
        60 * (date1.getMinutes() - date2.getMinutes()) +
        date1.getSeconds() -
        date2.getSeconds());
}
const isBetween = (ts, ts1, ts2) => {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
const duration = {
    DAY: 86400000,
};
function getDefaultHours(config) {
    let hours = config.defaultHour;
    let minutes = config.defaultMinute;
    let seconds = config.defaultSeconds;
    if (config.minDate !== undefined) {
        const minHour = config.minDate.getHours();
        const minMinutes = config.minDate.getMinutes();
        const minSeconds = config.minDate.getSeconds();
        if (hours < minHour) {
            hours = minHour;
        }
        if (hours === minHour && minutes < minMinutes) {
            minutes = minMinutes;
        }
        if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
            seconds = config.minDate.getSeconds();
    }
    if (config.maxDate !== undefined) {
        const maxHr = config.maxDate.getHours();
        const maxMinutes = config.maxDate.getMinutes();
        hours = Math.min(hours, maxHr);
        if (hours === maxHr)
            minutes = Math.min(maxMinutes, minutes);
        if (hours === maxHr && minutes === maxMinutes)
            seconds = config.maxDate.getSeconds();
    }
    return { hours, minutes, seconds };
}


/***/ }),

/***/ "./node_modules/flatpickr/dist/esm/utils/dom.js":
/*!******************************************************!*\
  !*** ./node_modules/flatpickr/dist/esm/utils/dom.js ***!
  \******************************************************/
/*! exports provided: toggleClass, createElement, clearNode, findParent, createNumberInput, getEventTarget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggleClass", function() { return toggleClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return createElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearNode", function() { return clearNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findParent", function() { return findParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNumberInput", function() { return createNumberInput; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEventTarget", function() { return getEventTarget; });
function toggleClass(elem, className, bool) {
    if (bool === true)
        return elem.classList.add(className);
    elem.classList.remove(className);
}
function createElement(tag, className, content) {
    const e = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e.className = className;
    if (content !== undefined)
        e.textContent = content;
    return e;
}
function clearNode(node) {
    while (node.firstChild)
        node.removeChild(node.firstChild);
}
function findParent(node, condition) {
    if (condition(node))
        return node;
    else if (node.parentNode)
        return findParent(node.parentNode, condition);
    return undefined;
}
function createNumberInput(inputClassName, opts) {
    const wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
        numInput.type = "number";
    }
    else {
        numInput.type = "text";
        numInput.pattern = "\\d*";
    }
    if (opts !== undefined)
        for (const key in opts)
            numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
}
function getEventTarget(event) {
    try {
        if (typeof event.composedPath === "function") {
            const path = event.composedPath();
            return path[0];
        }
        return event.target;
    }
    catch (error) {
        return event.target;
    }
}


/***/ }),

/***/ "./node_modules/flatpickr/dist/esm/utils/formatting.js":
/*!*************************************************************!*\
  !*** ./node_modules/flatpickr/dist/esm/utils/formatting.js ***!
  \*************************************************************/
/*! exports provided: monthToStr, revFormat, tokenRegex, formats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monthToStr", function() { return monthToStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "revFormat", function() { return revFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenRegex", function() { return tokenRegex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formats", function() { return formats; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/flatpickr/dist/esm/utils/index.js");

const doNothing = () => undefined;
const monthToStr = (monthNumber, shorthand, locale) => locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
const revFormat = {
    D: doNothing,
    F: function (dateObj, monthName, locale) {
        dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: (dateObj, hour) => {
        dateObj.setHours(parseFloat(hour));
    },
    H: (dateObj, hour) => {
        dateObj.setHours(parseFloat(hour));
    },
    J: (dateObj, day) => {
        dateObj.setDate(parseFloat(day));
    },
    K: (dateObj, amPM, locale) => {
        dateObj.setHours((dateObj.getHours() % 12) +
            12 * Object(_utils__WEBPACK_IMPORTED_MODULE_0__["int"])(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function (dateObj, shortMonth, locale) {
        dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: (dateObj, seconds) => {
        dateObj.setSeconds(parseFloat(seconds));
    },
    U: (_, unixSeconds) => new Date(parseFloat(unixSeconds) * 1000),
    W: function (dateObj, weekNum, locale) {
        const weekNumber = parseInt(weekNum);
        const date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
        date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
        return date;
    },
    Y: (dateObj, year) => {
        dateObj.setFullYear(parseFloat(year));
    },
    Z: (_, ISODate) => new Date(ISODate),
    d: (dateObj, day) => {
        dateObj.setDate(parseFloat(day));
    },
    h: (dateObj, hour) => {
        dateObj.setHours(parseFloat(hour));
    },
    i: (dateObj, minutes) => {
        dateObj.setMinutes(parseFloat(minutes));
    },
    j: (dateObj, day) => {
        dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: (dateObj, month) => {
        dateObj.setMonth(parseFloat(month) - 1);
    },
    n: (dateObj, month) => {
        dateObj.setMonth(parseFloat(month) - 1);
    },
    s: (dateObj, seconds) => {
        dateObj.setSeconds(parseFloat(seconds));
    },
    u: (_, unixMillSeconds) => new Date(parseFloat(unixMillSeconds)),
    w: doNothing,
    y: (dateObj, year) => {
        dateObj.setFullYear(2000 + parseFloat(year));
    },
};
const tokenRegex = {
    D: "(\\w+)",
    F: "(\\w+)",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "(\\w+)",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "(\\w+)",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})",
};
const formats = {
    Z: (date) => date.toISOString(),
    D: function (date, locale, options) {
        return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    F: function (date, locale, options) {
        return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    G: function (date, locale, options) {
        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["pad"])(formats.h(date, locale, options));
    },
    H: (date) => Object(_utils__WEBPACK_IMPORTED_MODULE_0__["pad"])(date.getHours()),
    J: function (date, locale) {
        return locale.ordinal !== undefined
            ? date.getDate() + locale.ordinal(date.getDate())
            : date.getDate();
    },
    K: (date, locale) => locale.amPM[Object(_utils__WEBPACK_IMPORTED_MODULE_0__["int"])(date.getHours() > 11)],
    M: function (date, locale) {
        return monthToStr(date.getMonth(), true, locale);
    },
    S: (date) => Object(_utils__WEBPACK_IMPORTED_MODULE_0__["pad"])(date.getSeconds()),
    U: (date) => date.getTime() / 1000,
    W: function (date, _, options) {
        return options.getWeek(date);
    },
    Y: (date) => Object(_utils__WEBPACK_IMPORTED_MODULE_0__["pad"])(date.getFullYear(), 4),
    d: (date) => Object(_utils__WEBPACK_IMPORTED_MODULE_0__["pad"])(date.getDate()),
    h: (date) => (date.getHours() % 12 ? date.getHours() % 12 : 12),
    i: (date) => Object(_utils__WEBPACK_IMPORTED_MODULE_0__["pad"])(date.getMinutes()),
    j: (date) => date.getDate(),
    l: function (date, locale) {
        return locale.weekdays.longhand[date.getDay()];
    },
    m: (date) => Object(_utils__WEBPACK_IMPORTED_MODULE_0__["pad"])(date.getMonth() + 1),
    n: (date) => date.getMonth() + 1,
    s: (date) => date.getSeconds(),
    u: (date) => date.getTime(),
    w: (date) => date.getDay(),
    y: (date) => String(date.getFullYear()).substring(2),
};


/***/ }),

/***/ "./node_modules/flatpickr/dist/esm/utils/index.js":
/*!********************************************************!*\
  !*** ./node_modules/flatpickr/dist/esm/utils/index.js ***!
  \********************************************************/
/*! exports provided: pad, int, debounce, arrayify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return pad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int", function() { return int; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayify", function() { return arrayify; });
const pad = (number, length = 2) => `000${number}`.slice(length * -1);
const int = (bool) => (bool === true ? 1 : 0);
function debounce(fn, wait) {
    let t;
    return function () {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, arguments), wait);
    };
}
const arrayify = (obj) => obj instanceof Array ? obj : [obj];


/***/ }),

/***/ "./node_modules/flatpickr/dist/esm/utils/polyfills.js":
/*!************************************************************!*\
  !*** ./node_modules/flatpickr/dist/esm/utils/polyfills.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (typeof Object.assign !== "function") {
    Object.assign = function (target, ...args) {
        if (!target) {
            throw TypeError("Cannot convert undefined or null to object");
        }
        for (const source of args) {
            if (source) {
                Object.keys(source).forEach((key) => (target[key] = source[key]));
            }
        }
        return target;
    };
}


/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ })

/******/ });
//# sourceMappingURL=admin.min.js.map